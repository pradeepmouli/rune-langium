# Research: Langium-to-Zod Schema Generator

**Feature**: 005-langium-zod
**Date**: 2026-02-18

## R-1: Existing TypeScript-to-Zod Tools

**Decision**: Build a Langium-native generator rather than adapting `ts-to-zod`

**Rationale**: `ts-to-zod` (npm) reads TypeScript interfaces via the TS Compiler API and emits Zod schemas. It works well for plain interfaces but cannot handle Langium-specific constructs:

| Feature | ts-to-zod | Langium-native |
|---------|-----------|----------------|
| `Reference<T>` cross-references | Emits full `Reference` object schema | Emits `z.string()` (ref text) |
| Cardinality `*` vs `+` | Both become `T[]` in TS — distinction lost | Grammar preserves `+` → `z.array().min(1)` |
| `$type` discriminator | Generic string field | `z.literal('TypeName')` for discriminated unions |
| Circular references | Crashes or emits `z.any()` | Cycle detection + `z.lazy()` |
| Internal metadata | Includes `$container`, `$cstNode` | Excludes by default |
| Union alternatives | Reads TS union syntax | Reads grammar alternatives directly |

`ts-to-zod` also requires the generated `ast.ts` file to exist and compile, making it a downstream tool. A grammar-native approach reads the source of truth directly.

**Alternatives considered**:
- **ts-to-zod with post-processing**: Generate schemas from `ast.ts`, then apply fixups for Reference/circular/internal fields. Fragile — changes with every ts-to-zod update.
- **io-ts or Typebox**: Alternative runtime validation libraries. Zod has won the ecosystem (react-hook-form, tRPC, Conform, etc.).
- **Manual schemas with conformance checks**: What we're doing for form-surface schemas in 004. Adequate for small projections but doesn't scale to full AST coverage.

---

## R-2: Langium Grammar Access

**Decision**: Read the grammar JSON (`langium-config.json` → generated grammar) via Langium's `GrammarAST` types

**Rationale**: Langium compiles `.langium` files into a JSON grammar representation that is already parsed into a typed AST. This JSON is generated by `langium generate` and lives alongside `ast.ts`. Reading it avoids needing a full Langium workspace setup.

The grammar AST provides:
- `ParserRule`: Each rule with its body (alternatives, groups, assignments)
- `Assignment`: Field name, operator (`=`, `+=`, `?=`), and terminal/rule reference
- `CrossReference`: Target type for `[Type]` syntax
- `Alternatives`: Union types for `A | B | C` patterns
- `AbstractType`: Interface-like types for type hierarchies

Key API: `loadGrammarFromJson(jsonPath)` from `langium/grammar` or direct JSON parse.

**Alternatives considered**:
- **Parse `.langium` files directly**: Requires bootstrapping a Langium workspace with the Langium grammar. More complex but gives access to scoping/linking. Reserved for future if needed.
- **Read `ast.ts` via TypeScript compiler**: Lower fidelity (cardinality lost), more complex setup.

---

## R-3: Cycle Detection Strategy

**Decision**: Tarjan's algorithm on the rule dependency graph

**Rationale**: Langium grammars commonly have cycles (e.g., `Data.superType → Data`, `Expression → BinaryExpression → Expression`). The generator must:

1. Build a directed graph: rule → referenced rules
2. Find strongly connected components (SCCs) via Tarjan's
3. For each SCC with >1 member, emit the first rule normally and all back-edges as `z.lazy()`
4. For self-referential rules (SCC of size 1 with self-edge), use `z.lazy()` for the self-reference

Expected cycles in Rune DSL grammar:
- `Data.superType → Data`
- `RosettaEnumeration.parent → RosettaEnumeration`
- `Expression` subtypes (if included)

---

## R-4: Output Format

**Decision**: Single generated TypeScript file with named exports

**Rationale**: Matches the pattern of Langium's own `ast.ts` output — a single file with all types. Benefits:

- Single import path: `import { DataSchema, AttributeSchema } from './generated/schemas.js'`
- Tree-shakeable: unused schemas eliminated by bundler
- Deterministic: no file-system ordering concerns
- Easy to diff and review in PRs

Header comment includes generation timestamp and grammar hash for traceability.

---

## R-5: Zod v4 Considerations

**Decision**: Target Zod v4 (current stable)

**Rationale**: Zod v4 is the current latest (4.3.x at time of writing). Key v4 features relevant to schema generation:

- `z.discriminatedUnion()` works with `$type` literal discriminators
- `z.lazy()` for recursive schemas (unchanged from v3)
- `z.string().min(1)` for non-empty strings
- `z.array().min(1)` for non-empty arrays (replaces `z.array().nonempty()` from v3)
- New `z.templateLiteral()` for pattern types (useful for qualified names)

Import path: `import { z } from 'zod'` (v4 is the default export).
