/******************************************************************************
 * This file was generated by langium-cli 4.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const RuneDslTerminals = {
  ID: /\^?[a-zA-Z_][a-zA-Z_0-9]*/,
  INT: /[0-9]+/,
  STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
  ML_COMMENT: /\/\*[\s\S]*?\*\//,
  SL_COMMENT: /\/\/[^\n\r]*/,
  WS: /\s+/
};

export type RuneDslTerminalNames = keyof typeof RuneDslTerminals;

export type RuneDslKeywordNames =
  | '('
  | ')'
  | '*'
  | '+'
  | ','
  | '-'
  | '->'
  | '->>'
  | '.'
  | '..'
  | '...'
  | '/'
  | ':'
  | ';'
  | '<'
  | '<='
  | '<>'
  | '='
  | '>'
  | '>='
  | 'ASATP'
  | 'E'
  | 'False'
  | 'T+1'
  | 'T+2'
  | 'T+3'
  | 'T+4'
  | 'T+5'
  | 'True'
  | '['
  | ']'
  | 'absent'
  | 'add'
  | 'alias'
  | 'all'
  | 'and'
  | 'annotation'
  | 'any'
  | 'as'
  | 'as-key'
  | 'basicType'
  | 'body'
  | 'choice'
  | 'componentID'
  | 'condition'
  | 'condition-func'
  | 'condition-path'
  | 'contains'
  | 'corpus'
  | 'count'
  | 'dateFormat'
  | 'default'
  | 'definition'
  | 'disjoint'
  | 'displayName'
  | 'distinct'
  | 'docReference'
  | 'e'
  | 'eligibility'
  | 'else'
  | 'empty'
  | 'enum'
  | 'enums'
  | 'exists'
  | 'extends'
  | 'extract'
  | 'filter'
  | 'first'
  | 'flatten'
  | 'for'
  | 'from'
  | 'func'
  | 'function'
  | 'hint'
  | 'if'
  | 'import'
  | 'in'
  | 'inputs'
  | 'is'
  | 'isEvent'
  | 'isProduct'
  | 'item'
  | 'join'
  | 'label'
  | 'last'
  | 'library'
  | 'mapper'
  | 'maps'
  | 'max'
  | 'merge'
  | 'meta'
  | 'metaType'
  | 'min'
  | 'multiple'
  | 'namespace'
  | 'one-of'
  | 'only'
  | 'only-element'
  | 'optional'
  | 'or'
  | 'output'
  | 'override'
  | 'path'
  | 'pattern'
  | 'post-condition'
  | 'prefix'
  | 'provision'
  | 'rationale'
  | 'rationale_author'
  | 'real-time'
  | 'recordType'
  | 'reduce'
  | 'regulatoryReference'
  | 'removeHtml'
  | 'report'
  | 'reportedField'
  | 'reporting'
  | 'required'
  | 'reverse'
  | 'root'
  | 'rosettaPath'
  | 'rule'
  | 'ruleReference'
  | 'scope'
  | 'segment'
  | 'set'
  | 'single'
  | 'sort'
  | 'source'
  | 'standard'
  | 'structured_provision'
  | 'sum'
  | 'super'
  | 'switch'
  | 'synonym'
  | 'tag'
  | 'then'
  | 'to'
  | 'to-date'
  | 'to-date-time'
  | 'to-enum'
  | 'to-int'
  | 'to-number'
  | 'to-string'
  | 'to-time'
  | 'to-zoned-date-time'
  | 'type'
  | 'typeAlias'
  | 'using'
  | 'value'
  | 'version'
  | 'when'
  | 'with'
  | 'with-meta'
  | '{'
  | '}';

export type RuneDslTokenNames = RuneDslTerminalNames | RuneDslKeywordNames;

export interface Annotation extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'Annotation';
  attributes: Array<Attribute>;
  definition?: string;
  name: ValidID;
  prefix?: ValidID;
}

export const Annotation = {
  $type: 'Annotation',
  attributes: 'attributes',
  definition: 'definition',
  name: 'name',
  prefix: 'prefix'
} as const;

export function isAnnotation(item: unknown): item is Annotation {
  return reflection.isInstance(item, Annotation.$type);
}

export interface AnnotationDeepPath extends langium.AstNode {
  readonly $container:
    | AnnotationDeepPath
    | AnnotationPath
    | LabelAnnotation
    | RosettaDocReference
    | RuleReferenceAnnotation;
  readonly $type: 'AnnotationDeepPath';
  attribute: langium.Reference<Attribute>;
  operator: '->>';
  receiver: AnnotationPathExpression;
}

export const AnnotationDeepPath = {
  $type: 'AnnotationDeepPath',
  attribute: 'attribute',
  operator: 'operator',
  receiver: 'receiver'
} as const;

export function isAnnotationDeepPath(item: unknown): item is AnnotationDeepPath {
  return reflection.isInstance(item, AnnotationDeepPath.$type);
}

export interface AnnotationPath extends langium.AstNode {
  readonly $container:
    | AnnotationDeepPath
    | AnnotationPath
    | LabelAnnotation
    | RosettaDocReference
    | RuleReferenceAnnotation;
  readonly $type: 'AnnotationPath';
  attribute: langium.Reference<Attribute>;
  operator: '->';
  receiver: AnnotationPathExpression;
}

export const AnnotationPath = {
  $type: 'AnnotationPath',
  attribute: 'attribute',
  operator: 'operator',
  receiver: 'receiver'
} as const;

export function isAnnotationPath(item: unknown): item is AnnotationPath {
  return reflection.isInstance(item, AnnotationPath.$type);
}

export interface AnnotationPathAttributeReference extends langium.AstNode {
  readonly $container:
    | AnnotationDeepPath
    | AnnotationPath
    | LabelAnnotation
    | RosettaDocReference
    | RuleReferenceAnnotation;
  readonly $type: 'AnnotationPathAttributeReference';
  attribute: langium.Reference<Attribute>;
}

export const AnnotationPathAttributeReference = {
  $type: 'AnnotationPathAttributeReference',
  attribute: 'attribute'
} as const;

export function isAnnotationPathAttributeReference(
  item: unknown
): item is AnnotationPathAttributeReference {
  return reflection.isInstance(item, AnnotationPathAttributeReference.$type);
}

export type AnnotationPathExpression =
  | AnnotationDeepPath
  | AnnotationPath
  | AnnotationPathAttributeReference
  | RosettaImplicitVariable;

export const AnnotationPathExpression = {
  $type: 'AnnotationPathExpression'
} as const;

export function isAnnotationPathExpression(item: unknown): item is AnnotationPathExpression {
  return reflection.isInstance(item, AnnotationPathExpression.$type);
}

export interface AnnotationQualifier extends langium.AstNode {
  readonly $container: AnnotationRef;
  readonly $type: 'AnnotationQualifier';
  qualName: string;
  qualPath?: RosettaAttributeReference;
  qualValue?: string;
}

export const AnnotationQualifier = {
  $type: 'AnnotationQualifier',
  qualName: 'qualName',
  qualPath: 'qualPath',
  qualValue: 'qualValue'
} as const;

export function isAnnotationQualifier(item: unknown): item is AnnotationQualifier {
  return reflection.isInstance(item, AnnotationQualifier.$type);
}

export interface AnnotationRef extends langium.AstNode {
  readonly $container:
    | Attribute
    | Choice
    | ChoiceOption
    | Condition
    | Data
    | RosettaEnumValue
    | RosettaEnumeration
    | RosettaFunction;
  readonly $type: 'AnnotationRef';
  annotation: langium.Reference<Annotation>;
  attribute?: langium.Reference<Attribute>;
  qualifiers: Array<AnnotationQualifier>;
}

export const AnnotationRef = {
  $type: 'AnnotationRef',
  annotation: 'annotation',
  attribute: 'attribute',
  qualifiers: 'qualifiers'
} as const;

export function isAnnotationRef(item: unknown): item is AnnotationRef {
  return reflection.isInstance(item, AnnotationRef.$type);
}

export interface ArithmeticOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ArithmeticOperation';
  left: RosettaExpression;
  operator: '*' | '+' | '-' | '/';
  right: RosettaExpression;
}

export const ArithmeticOperation = {
  $type: 'ArithmeticOperation',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isArithmeticOperation(item: unknown): item is ArithmeticOperation {
  return reflection.isInstance(item, ArithmeticOperation.$type);
}

export interface AsKeyOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'AsKeyOperation';
  argument: RosettaExpression;
  operator: 'as-key';
}

export const AsKeyOperation = {
  $type: 'AsKeyOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isAsKeyOperation(item: unknown): item is AsKeyOperation {
  return reflection.isInstance(item, AsKeyOperation.$type);
}

export type AssignPathRoot = Attribute | ShortcutDeclaration;

export const AssignPathRoot = {
  $type: 'AssignPathRoot'
} as const;

export function isAssignPathRoot(item: unknown): item is AssignPathRoot {
  return reflection.isInstance(item, AssignPathRoot.$type);
}

export interface Attribute extends langium.AstNode {
  readonly $container: Annotation | Data | RosettaFunction;
  readonly $type: 'Attribute';
  annotations: Array<AnnotationRef>;
  card: RosettaCardinality;
  definition?: string;
  labels: Array<LabelAnnotation>;
  name: ValidID;
  override: boolean;
  references: Array<RosettaDocReference>;
  ruleReferences: Array<RuleReferenceAnnotation>;
  synonyms: Array<RosettaSynonym>;
  typeCall: TypeCall;
}

export const Attribute = {
  $type: 'Attribute',
  annotations: 'annotations',
  card: 'card',
  definition: 'definition',
  labels: 'labels',
  name: 'name',
  override: 'override',
  references: 'references',
  ruleReferences: 'ruleReferences',
  synonyms: 'synonyms',
  typeCall: 'typeCall'
} as const;

export function isAttribute(item: unknown): item is Attribute {
  return reflection.isInstance(item, Attribute.$type);
}

export type BigDecimal = string;

export function isBigDecimal(item: unknown): item is BigDecimal {
  return typeof item === 'string';
}

export type CardinalityModifier = 'all' | 'any';

export function isCardinalityModifier(item: unknown): item is CardinalityModifier {
  return item === 'any' || item === 'all';
}

export interface Choice extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'Choice';
  annotations: Array<AnnotationRef>;
  attributes: Array<ChoiceOption>;
  definition?: string;
  name: ValidID;
  synonyms: Array<RosettaClassSynonym>;
}

export const Choice = {
  $type: 'Choice',
  annotations: 'annotations',
  attributes: 'attributes',
  definition: 'definition',
  name: 'name',
  synonyms: 'synonyms'
} as const;

export function isChoice(item: unknown): item is Choice {
  return reflection.isInstance(item, Choice.$type);
}

export interface ChoiceOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ChoiceOperation';
  argument?: RosettaExpression;
  attributes: Array<langium.Reference<Attribute>>;
  necessity: Necessity;
  operator: 'choice';
}

export const ChoiceOperation = {
  $type: 'ChoiceOperation',
  argument: 'argument',
  attributes: 'attributes',
  necessity: 'necessity',
  operator: 'operator'
} as const;

export function isChoiceOperation(item: unknown): item is ChoiceOperation {
  return reflection.isInstance(item, ChoiceOperation.$type);
}

export interface ChoiceOption extends langium.AstNode {
  readonly $container: Choice;
  readonly $type: 'ChoiceOption';
  annotations: Array<AnnotationRef>;
  definition?: string;
  labels: Array<LabelAnnotation>;
  references: Array<RosettaDocReference>;
  ruleReferences: Array<RuleReferenceAnnotation>;
  synonyms: Array<RosettaSynonym>;
  typeCall: TypeCall;
}

export const ChoiceOption = {
  $type: 'ChoiceOption',
  annotations: 'annotations',
  definition: 'definition',
  labels: 'labels',
  references: 'references',
  ruleReferences: 'ruleReferences',
  synonyms: 'synonyms',
  typeCall: 'typeCall'
} as const;

export function isChoiceOption(item: unknown): item is ChoiceOption {
  return reflection.isInstance(item, ChoiceOption.$type);
}

export interface ClosureParameter extends langium.AstNode {
  readonly $container: InlineFunction;
  readonly $type: 'ClosureParameter';
  name: string;
}

export const ClosureParameter = {
  $type: 'ClosureParameter',
  name: 'name'
} as const;

export function isClosureParameter(item: unknown): item is ClosureParameter {
  return reflection.isInstance(item, ClosureParameter.$type);
}

export interface ComparisonOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ComparisonOperation';
  cardMod?: CardinalityModifier;
  left?: RosettaExpression;
  operator: '<' | '<=' | '>' | '>=';
  right: RosettaExpression;
}

export const ComparisonOperation = {
  $type: 'ComparisonOperation',
  cardMod: 'cardMod',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isComparisonOperation(item: unknown): item is ComparisonOperation {
  return reflection.isInstance(item, ComparisonOperation.$type);
}

export interface Condition extends langium.AstNode {
  readonly $container: Data | RosettaFunction | RosettaTypeAlias;
  readonly $type: 'Condition';
  annotations: Array<AnnotationRef>;
  definition?: string;
  expression: RosettaExpression;
  name?: ValidID;
  postCondition: boolean;
  references: Array<RosettaDocReference>;
}

export const Condition = {
  $type: 'Condition',
  annotations: 'annotations',
  definition: 'definition',
  expression: 'expression',
  name: 'name',
  postCondition: 'postCondition',
  references: 'references'
} as const;

export function isCondition(item: unknown): item is Condition {
  return reflection.isInstance(item, Condition.$type);
}

export interface ConstructorKeyValuePair extends langium.AstNode {
  readonly $container: RosettaConstructorExpression;
  readonly $type: 'ConstructorKeyValuePair';
  key: langium.Reference<RosettaFeature>;
  value: RosettaExpression;
}

export const ConstructorKeyValuePair = {
  $type: 'ConstructorKeyValuePair',
  key: 'key',
  value: 'value'
} as const;

export function isConstructorKeyValuePair(item: unknown): item is ConstructorKeyValuePair {
  return reflection.isInstance(item, ConstructorKeyValuePair.$type);
}

export interface Data extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'Data';
  annotations: Array<AnnotationRef>;
  attributes: Array<Attribute>;
  conditions: Array<Condition>;
  definition?: string;
  name: ValidID;
  references: Array<RosettaDocReference>;
  superType?: langium.Reference<Data>;
  synonyms: Array<RosettaClassSynonym>;
}

export const Data = {
  $type: 'Data',
  annotations: 'annotations',
  attributes: 'attributes',
  conditions: 'conditions',
  definition: 'definition',
  name: 'name',
  references: 'references',
  superType: 'superType',
  synonyms: 'synonyms'
} as const;

export function isData(item: unknown): item is Data {
  return reflection.isInstance(item, Data.$type);
}

export interface DefaultOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'DefaultOperation';
  left?: RosettaExpression;
  operator: 'default';
  right: RosettaExpression;
}

export const DefaultOperation = {
  $type: 'DefaultOperation',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isDefaultOperation(item: unknown): item is DefaultOperation {
  return reflection.isInstance(item, DefaultOperation.$type);
}

export interface DistinctOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'DistinctOperation';
  argument?: RosettaExpression;
  operator: 'distinct';
}

export const DistinctOperation = {
  $type: 'DistinctOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isDistinctOperation(item: unknown): item is DistinctOperation {
  return reflection.isInstance(item, DistinctOperation.$type);
}

export interface DocumentRationale extends langium.AstNode {
  readonly $container: RosettaDocReference;
  readonly $type: 'DocumentRationale';
  rationale: string;
  rationaleAuthor?: string;
}

export const DocumentRationale = {
  $type: 'DocumentRationale',
  rationale: 'rationale',
  rationaleAuthor: 'rationaleAuthor'
} as const;

export function isDocumentRationale(item: unknown): item is DocumentRationale {
  return reflection.isInstance(item, DocumentRationale.$type);
}

export interface EqualityOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'EqualityOperation';
  cardMod?: CardinalityModifier;
  left?: RosettaExpression;
  operator: '<>' | '=';
  right: RosettaExpression;
}

export const EqualityOperation = {
  $type: 'EqualityOperation',
  cardMod: 'cardMod',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isEqualityOperation(item: unknown): item is EqualityOperation {
  return reflection.isInstance(item, EqualityOperation.$type);
}

export type ExistsModifier = 'multiple' | 'single';

export function isExistsModifier(item: unknown): item is ExistsModifier {
  return item === 'single' || item === 'multiple';
}

export type ExternalValueOperator = '+' | '-';

export function isExternalValueOperator(item: unknown): item is ExternalValueOperator {
  return item === '+' || item === '-';
}

export interface FilterOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'FilterOperation';
  argument?: RosettaExpression;
  function?: InlineFunction;
  operator: 'filter';
}

export const FilterOperation = {
  $type: 'FilterOperation',
  argument: 'argument',
  function: 'function',
  operator: 'operator'
} as const;

export function isFilterOperation(item: unknown): item is FilterOperation {
  return reflection.isInstance(item, FilterOperation.$type);
}

export interface FirstOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'FirstOperation';
  argument?: RosettaExpression;
  operator: 'first';
}

export const FirstOperation = {
  $type: 'FirstOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isFirstOperation(item: unknown): item is FirstOperation {
  return reflection.isInstance(item, FirstOperation.$type);
}

export interface FlattenOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'FlattenOperation';
  argument?: RosettaExpression;
  operator: 'flatten';
}

export const FlattenOperation = {
  $type: 'FlattenOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isFlattenOperation(item: unknown): item is FlattenOperation {
  return reflection.isInstance(item, FlattenOperation.$type);
}

export interface Import extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'Import';
  importedNamespace: QualifiedNameWithWildcard;
  namespaceAlias?: ValidID;
}

export const Import = {
  $type: 'Import',
  importedNamespace: 'importedNamespace',
  namespaceAlias: 'namespaceAlias'
} as const;

export function isImport(item: unknown): item is Import {
  return reflection.isInstance(item, Import.$type);
}

export interface InlineFunction extends langium.AstNode {
  readonly $container:
    | FilterOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | ReduceOperation
    | SortOperation
    | ThenOperation;
  readonly $type: 'InlineFunction';
  body: RosettaExpression;
  parameters: Array<ClosureParameter>;
}

export const InlineFunction = {
  $type: 'InlineFunction',
  body: 'body',
  parameters: 'parameters'
} as const;

export function isInlineFunction(item: unknown): item is InlineFunction {
  return reflection.isInstance(item, InlineFunction.$type);
}

export type Integer = bigint;

export function isInteger(item: unknown): item is Integer {
  return typeof item === 'bigint';
}

export interface JoinOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'JoinOperation';
  left?: RosettaExpression;
  operator: 'join';
  right?: RosettaExpression;
}

export const JoinOperation = {
  $type: 'JoinOperation',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isJoinOperation(item: unknown): item is JoinOperation {
  return reflection.isInstance(item, JoinOperation.$type);
}

export interface LabelAnnotation extends langium.AstNode {
  readonly $container: Attribute | ChoiceOption;
  readonly $type: 'LabelAnnotation';
  deprecatedAs: boolean;
  label: string;
  name: 'label';
  path?: AnnotationPathExpression;
}

export const LabelAnnotation = {
  $type: 'LabelAnnotation',
  deprecatedAs: 'deprecatedAs',
  label: 'label',
  name: 'name',
  path: 'path'
} as const;

export function isLabelAnnotation(item: unknown): item is LabelAnnotation {
  return reflection.isInstance(item, LabelAnnotation.$type);
}

export interface LastOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'LastOperation';
  argument?: RosettaExpression;
  operator: 'last';
}

export const LastOperation = {
  $type: 'LastOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isLastOperation(item: unknown): item is LastOperation {
  return reflection.isInstance(item, LastOperation.$type);
}

export interface ListLiteral extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ListLiteral';
  elements: Array<RosettaExpression>;
}

export const ListLiteral = {
  $type: 'ListLiteral',
  elements: 'elements'
} as const;

export function isListLiteral(item: unknown): item is ListLiteral {
  return reflection.isInstance(item, ListLiteral.$type);
}

export interface LogicalOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'LogicalOperation';
  left: RosettaExpression;
  operator: 'and' | 'or';
  right: RosettaExpression;
}

export const LogicalOperation = {
  $type: 'LogicalOperation',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isLogicalOperation(item: unknown): item is LogicalOperation {
  return reflection.isInstance(item, LogicalOperation.$type);
}

export interface MapOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'MapOperation';
  argument?: RosettaExpression;
  function?: InlineFunction;
  operator: 'extract';
}

export const MapOperation = {
  $type: 'MapOperation',
  argument: 'argument',
  function: 'function',
  operator: 'operator'
} as const;

export function isMapOperation(item: unknown): item is MapOperation {
  return reflection.isInstance(item, MapOperation.$type);
}

export interface MaxOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'MaxOperation';
  argument?: RosettaExpression;
  function?: InlineFunction;
  operator: 'max';
}

export const MaxOperation = {
  $type: 'MaxOperation',
  argument: 'argument',
  function: 'function',
  operator: 'operator'
} as const;

export function isMaxOperation(item: unknown): item is MaxOperation {
  return reflection.isInstance(item, MaxOperation.$type);
}

export interface MinOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'MinOperation';
  argument?: RosettaExpression;
  function?: InlineFunction;
  operator: 'min';
}

export const MinOperation = {
  $type: 'MinOperation',
  argument: 'argument',
  function: 'function',
  operator: 'operator'
} as const;

export function isMinOperation(item: unknown): item is MinOperation {
  return reflection.isInstance(item, MinOperation.$type);
}

export type Necessity = 'optional' | 'required';

export function isNecessity(item: unknown): item is Necessity {
  return item === 'optional' || item === 'required';
}

export interface OneOfOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'OneOfOperation';
  argument?: RosettaExpression;
  operator: 'one-of';
}

export const OneOfOperation = {
  $type: 'OneOfOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isOneOfOperation(item: unknown): item is OneOfOperation {
  return reflection.isInstance(item, OneOfOperation.$type);
}

export interface Operation extends langium.AstNode {
  readonly $container: RosettaFunction;
  readonly $type: 'Operation';
  add: boolean;
  assignRoot: langium.Reference<AssignPathRoot>;
  definition?: string;
  expression: RosettaExpression;
  path?: Segment;
}

export const Operation = {
  $type: 'Operation',
  add: 'add',
  assignRoot: 'assignRoot',
  definition: 'definition',
  expression: 'expression',
  path: 'path'
} as const;

export function isOperation(item: unknown): item is Operation {
  return reflection.isInstance(item, Operation.$type);
}

export type QualifiedName = string;

export function isQualifiedName(item: unknown): item is QualifiedName {
  return typeof item === 'string';
}

export type QualifiedNameWithWildcard = string;

export function isQualifiedNameWithWildcard(item: unknown): item is QualifiedNameWithWildcard {
  return typeof item === 'string';
}

export interface ReduceOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ReduceOperation';
  argument?: RosettaExpression;
  function?: InlineFunction;
  operator: 'reduce';
}

export const ReduceOperation = {
  $type: 'ReduceOperation',
  argument: 'argument',
  function: 'function',
  operator: 'operator'
} as const;

export function isReduceOperation(item: unknown): item is ReduceOperation {
  return reflection.isInstance(item, ReduceOperation.$type);
}

export interface RegulatoryDocumentReference extends langium.AstNode {
  readonly $container: RosettaDocReference | RosettaReport;
  readonly $type: 'RegulatoryDocumentReference';
  body: langium.Reference<RosettaBody>;
  corpusList: Array<langium.Reference<RosettaCorpus>>;
  segments: Array<RosettaSegmentRef>;
}

export const RegulatoryDocumentReference = {
  $type: 'RegulatoryDocumentReference',
  body: 'body',
  corpusList: 'corpusList',
  segments: 'segments'
} as const;

export function isRegulatoryDocumentReference(item: unknown): item is RegulatoryDocumentReference {
  return reflection.isInstance(item, RegulatoryDocumentReference.$type);
}

export interface ReverseOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ReverseOperation';
  argument?: RosettaExpression;
  operator: 'reverse';
}

export const ReverseOperation = {
  $type: 'ReverseOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isReverseOperation(item: unknown): item is ReverseOperation {
  return reflection.isInstance(item, ReverseOperation.$type);
}

export interface RosettaAbsentExpression extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaAbsentExpression';
  argument?: RosettaExpression;
  operator: 'absent';
}

export const RosettaAbsentExpression = {
  $type: 'RosettaAbsentExpression',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isRosettaAbsentExpression(item: unknown): item is RosettaAbsentExpression {
  return reflection.isInstance(item, RosettaAbsentExpression.$type);
}

export interface RosettaAttributeReference extends langium.AstNode {
  readonly $container: AnnotationQualifier | RosettaAttributeReference | RosettaMapRosettaPath;
  readonly $type: 'RosettaAttributeReference' | 'RosettaDataReference';
  attribute: langium.Reference<Attribute>;
  receiver: RosettaDataReference;
}

export const RosettaAttributeReference = {
  $type: 'RosettaAttributeReference',
  attribute: 'attribute',
  receiver: 'receiver'
} as const;

export function isRosettaAttributeReference(item: unknown): item is RosettaAttributeReference {
  return reflection.isInstance(item, RosettaAttributeReference.$type);
}

export interface RosettaBasicType extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaBasicType';
  definition?: string;
  name: ValidID;
  parameters: Array<TypeParameter>;
}

export const RosettaBasicType = {
  $type: 'RosettaBasicType',
  definition: 'definition',
  name: 'name',
  parameters: 'parameters'
} as const;

export function isRosettaBasicType(item: unknown): item is RosettaBasicType {
  return reflection.isInstance(item, RosettaBasicType.$type);
}

export interface RosettaBody extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaBody';
  bodyType: string;
  definition?: string;
  name: ValidID;
}

export const RosettaBody = {
  $type: 'RosettaBody',
  bodyType: 'bodyType',
  definition: 'definition',
  name: 'name'
} as const;

export function isRosettaBody(item: unknown): item is RosettaBody {
  return reflection.isInstance(item, RosettaBody.$type);
}

export interface RosettaBooleanLiteral extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaMapTestEqualityOperation
    | RosettaMappingInstance
    | RosettaMappingPathTests
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseGuard
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaBooleanLiteral';
  value: boolean;
}

export const RosettaBooleanLiteral = {
  $type: 'RosettaBooleanLiteral',
  value: 'value'
} as const;

export function isRosettaBooleanLiteral(item: unknown): item is RosettaBooleanLiteral {
  return reflection.isInstance(item, RosettaBooleanLiteral.$type);
}

export type RosettaCallableWithArgs = RosettaExternalFunction | RosettaFunction | RosettaRule;

export const RosettaCallableWithArgs = {
  $type: 'RosettaCallableWithArgs'
} as const;

export function isRosettaCallableWithArgs(item: unknown): item is RosettaCallableWithArgs {
  return reflection.isInstance(item, RosettaCallableWithArgs.$type);
}

export interface RosettaCardinality extends langium.AstNode {
  readonly $container: Attribute;
  readonly $type: 'RosettaCardinality';
  inf: number;
  sup?: number;
  unbounded: boolean;
}

export const RosettaCardinality = {
  $type: 'RosettaCardinality',
  inf: 'inf',
  sup: 'sup',
  unbounded: 'unbounded'
} as const;

export function isRosettaCardinality(item: unknown): item is RosettaCardinality {
  return reflection.isInstance(item, RosettaCardinality.$type);
}

export interface RosettaClassSynonym extends langium.AstNode {
  readonly $container: Choice | Data;
  readonly $type: 'RosettaClassSynonym';
  metaValue?: RosettaSynonymValueBase;
  sources: Array<langium.Reference<RosettaSynonymSource>>;
  value?: RosettaSynonymValueBase;
}

export const RosettaClassSynonym = {
  $type: 'RosettaClassSynonym',
  metaValue: 'metaValue',
  sources: 'sources',
  value: 'value'
} as const;

export function isRosettaClassSynonym(item: unknown): item is RosettaClassSynonym {
  return reflection.isInstance(item, RosettaClassSynonym.$type);
}

export interface RosettaConditionalExpression extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaConditionalExpression';
  elsethen?: RosettaExpression;
  full: boolean;
  if?: RosettaExpression;
  ifthen?: RosettaExpression;
}

export const RosettaConditionalExpression = {
  $type: 'RosettaConditionalExpression',
  elsethen: 'elsethen',
  full: 'full',
  if: 'if',
  ifthen: 'ifthen'
} as const;

export function isRosettaConditionalExpression(
  item: unknown
): item is RosettaConditionalExpression {
  return reflection.isInstance(item, RosettaConditionalExpression.$type);
}

export interface RosettaConstructorExpression extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaConstructorExpression';
  constructorTypeArgs: Array<TypeCallArgument>;
  implicitEmpty: boolean;
  typeRef: RosettaSuperCall | RosettaSymbolReference;
  values: Array<ConstructorKeyValuePair>;
}

export const RosettaConstructorExpression = {
  $type: 'RosettaConstructorExpression',
  constructorTypeArgs: 'constructorTypeArgs',
  implicitEmpty: 'implicitEmpty',
  typeRef: 'typeRef',
  values: 'values'
} as const;

export function isRosettaConstructorExpression(
  item: unknown
): item is RosettaConstructorExpression {
  return reflection.isInstance(item, RosettaConstructorExpression.$type);
}

export interface RosettaContainsExpression extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaContainsExpression';
  left?: RosettaExpression;
  operator: 'contains';
  right: RosettaExpression;
}

export const RosettaContainsExpression = {
  $type: 'RosettaContainsExpression',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isRosettaContainsExpression(item: unknown): item is RosettaContainsExpression {
  return reflection.isInstance(item, RosettaContainsExpression.$type);
}

export interface RosettaCorpus extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaCorpus';
  body?: langium.Reference<RosettaBody>;
  corpusType: string;
  definition?: string;
  displayName?: string;
  name: ValidID;
}

export const RosettaCorpus = {
  $type: 'RosettaCorpus',
  body: 'body',
  corpusType: 'corpusType',
  definition: 'definition',
  displayName: 'displayName',
  name: 'name'
} as const;

export function isRosettaCorpus(item: unknown): item is RosettaCorpus {
  return reflection.isInstance(item, RosettaCorpus.$type);
}

export interface RosettaCountOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaCountOperation';
  argument?: RosettaExpression;
  operator: 'count';
}

export const RosettaCountOperation = {
  $type: 'RosettaCountOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isRosettaCountOperation(item: unknown): item is RosettaCountOperation {
  return reflection.isInstance(item, RosettaCountOperation.$type);
}

export interface RosettaDataReference extends RosettaAttributeReference {
  readonly $container: RosettaAttributeReference;
  readonly $type: 'RosettaDataReference';
  data: langium.Reference<Data>;
}

export const RosettaDataReference = {
  $type: 'RosettaDataReference',
  attribute: 'attribute',
  data: 'data',
  receiver: 'receiver'
} as const;

export function isRosettaDataReference(item: unknown): item is RosettaDataReference {
  return reflection.isInstance(item, RosettaDataReference.$type);
}

export interface RosettaDeepFeatureCall extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaDeepFeatureCall';
  feature?: langium.Reference<Attribute>;
  receiver: RosettaExpression;
}

export const RosettaDeepFeatureCall = {
  $type: 'RosettaDeepFeatureCall',
  feature: 'feature',
  receiver: 'receiver'
} as const;

export function isRosettaDeepFeatureCall(item: unknown): item is RosettaDeepFeatureCall {
  return reflection.isInstance(item, RosettaDeepFeatureCall.$type);
}

export interface RosettaDisjointExpression extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaDisjointExpression';
  left?: RosettaExpression;
  operator: 'disjoint';
  right: RosettaExpression;
}

export const RosettaDisjointExpression = {
  $type: 'RosettaDisjointExpression',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isRosettaDisjointExpression(item: unknown): item is RosettaDisjointExpression {
  return reflection.isInstance(item, RosettaDisjointExpression.$type);
}

export interface RosettaDocReference extends langium.AstNode {
  readonly $container:
    | Attribute
    | ChoiceOption
    | Condition
    | Data
    | RosettaEnumValue
    | RosettaEnumeration
    | RosettaFunction
    | RosettaRule;
  readonly $type: 'RosettaDocReference';
  docReference: RegulatoryDocumentReference;
  name: 'docReference' | 'regulatoryReference';
  path?: AnnotationPathExpression;
  provision?: string;
  rationales: Array<DocumentRationale>;
  reportedField: boolean;
  structuredProvision?: string;
}

export const RosettaDocReference = {
  $type: 'RosettaDocReference',
  docReference: 'docReference',
  name: 'name',
  path: 'path',
  provision: 'provision',
  rationales: 'rationales',
  reportedField: 'reportedField',
  structuredProvision: 'structuredProvision'
} as const;

export function isRosettaDocReference(item: unknown): item is RosettaDocReference {
  return reflection.isInstance(item, RosettaDocReference.$type);
}

export interface RosettaEnumeration extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaEnumeration';
  annotations: Array<AnnotationRef>;
  definition?: string;
  enumValues: Array<RosettaEnumValue>;
  name: ValidID;
  parent?: langium.Reference<RosettaEnumeration>;
  references: Array<RosettaDocReference>;
  synonyms: Array<RosettaSynonym>;
}

export const RosettaEnumeration = {
  $type: 'RosettaEnumeration',
  annotations: 'annotations',
  definition: 'definition',
  enumValues: 'enumValues',
  name: 'name',
  parent: 'parent',
  references: 'references',
  synonyms: 'synonyms'
} as const;

export function isRosettaEnumeration(item: unknown): item is RosettaEnumeration {
  return reflection.isInstance(item, RosettaEnumeration.$type);
}

export interface RosettaEnumSynonym extends langium.AstNode {
  readonly $container: RosettaEnumValue | RosettaExternalEnumValue;
  readonly $type: 'RosettaEnumSynonym';
  definition?: string;
  patternMatch?: string;
  patternReplace?: string;
  removeHtml: boolean;
  sources: Array<langium.Reference<RosettaSynonymSource>>;
  synonymValue: string;
}

export const RosettaEnumSynonym = {
  $type: 'RosettaEnumSynonym',
  definition: 'definition',
  patternMatch: 'patternMatch',
  patternReplace: 'patternReplace',
  removeHtml: 'removeHtml',
  sources: 'sources',
  synonymValue: 'synonymValue'
} as const;

export function isRosettaEnumSynonym(item: unknown): item is RosettaEnumSynonym {
  return reflection.isInstance(item, RosettaEnumSynonym.$type);
}

export interface RosettaEnumValue extends langium.AstNode {
  readonly $container: RosettaEnumeration;
  readonly $type: 'RosettaEnumValue';
  annotations: Array<AnnotationRef>;
  definition?: string;
  display?: string;
  enumSynonyms: Array<RosettaEnumSynonym>;
  name: ValidID;
  references: Array<RosettaDocReference>;
}

export const RosettaEnumValue = {
  $type: 'RosettaEnumValue',
  annotations: 'annotations',
  definition: 'definition',
  display: 'display',
  enumSynonyms: 'enumSynonyms',
  name: 'name',
  references: 'references'
} as const;

export function isRosettaEnumValue(item: unknown): item is RosettaEnumValue {
  return reflection.isInstance(item, RosettaEnumValue.$type);
}

export interface RosettaEnumValueReference extends langium.AstNode {
  readonly $container:
    | RosettaFunction
    | RosettaMapTestEqualityOperation
    | RosettaMappingInstance
    | RosettaMappingPathTests;
  readonly $type: 'RosettaEnumValueReference';
  enumeration: langium.Reference<RosettaEnumeration>;
  value: langium.Reference<RosettaEnumValue>;
}

export const RosettaEnumValueReference = {
  $type: 'RosettaEnumValueReference',
  enumeration: 'enumeration',
  value: 'value'
} as const;

export function isRosettaEnumValueReference(item: unknown): item is RosettaEnumValueReference {
  return reflection.isInstance(item, RosettaEnumValueReference.$type);
}

export interface RosettaExistsExpression extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaExistsExpression';
  argument?: RosettaExpression;
  modifier?: ExistsModifier;
  operator: 'exists';
}

export const RosettaExistsExpression = {
  $type: 'RosettaExistsExpression',
  argument: 'argument',
  modifier: 'modifier',
  operator: 'operator'
} as const;

export function isRosettaExistsExpression(item: unknown): item is RosettaExistsExpression {
  return reflection.isInstance(item, RosettaExistsExpression.$type);
}

export type RosettaExpression =
  | ArithmeticOperation
  | AsKeyOperation
  | ChoiceOperation
  | ComparisonOperation
  | DefaultOperation
  | DistinctOperation
  | EqualityOperation
  | FilterOperation
  | FirstOperation
  | FlattenOperation
  | JoinOperation
  | LastOperation
  | ListLiteral
  | LogicalOperation
  | MapOperation
  | MaxOperation
  | MinOperation
  | OneOfOperation
  | ReduceOperation
  | ReverseOperation
  | RosettaAbsentExpression
  | RosettaConditionalExpression
  | RosettaConstructorExpression
  | RosettaContainsExpression
  | RosettaCountOperation
  | RosettaDeepFeatureCall
  | RosettaDisjointExpression
  | RosettaExistsExpression
  | RosettaFeatureCall
  | RosettaImplicitVariable
  | RosettaLiteral
  | RosettaOnlyElement
  | RosettaOnlyExistsExpression
  | RosettaSuperCall
  | RosettaSymbolReference
  | SortOperation
  | SumOperation
  | SwitchOperation
  | ThenOperation
  | ToDateOperation
  | ToDateTimeOperation
  | ToEnumOperation
  | ToIntOperation
  | ToNumberOperation
  | ToStringOperation
  | ToTimeOperation
  | ToZonedDateTimeOperation
  | WithMetaOperation;

export const RosettaExpression = {
  $type: 'RosettaExpression'
} as const;

export function isRosettaExpression(item: unknown): item is RosettaExpression {
  return reflection.isInstance(item, RosettaExpression.$type);
}

export interface RosettaExternalClass extends langium.AstNode {
  readonly $container: RosettaExternalRuleSource | RosettaSynonymSource;
  readonly $type: 'RosettaExternalClass';
  data: langium.Reference<Data>;
  externalClassSynonyms: Array<RosettaExternalClassSynonym>;
  regularAttributes: Array<RosettaExternalRegularAttribute>;
}

export const RosettaExternalClass = {
  $type: 'RosettaExternalClass',
  data: 'data',
  externalClassSynonyms: 'externalClassSynonyms',
  regularAttributes: 'regularAttributes'
} as const;

export function isRosettaExternalClass(item: unknown): item is RosettaExternalClass {
  return reflection.isInstance(item, RosettaExternalClass.$type);
}

export interface RosettaExternalClassSynonym extends langium.AstNode {
  readonly $container: RosettaExternalClass;
  readonly $type: 'RosettaExternalClassSynonym';
  metaValue: RosettaSynonymValueBase;
  value?: RosettaSynonymValueBase;
}

export const RosettaExternalClassSynonym = {
  $type: 'RosettaExternalClassSynonym',
  metaValue: 'metaValue',
  value: 'value'
} as const;

export function isRosettaExternalClassSynonym(item: unknown): item is RosettaExternalClassSynonym {
  return reflection.isInstance(item, RosettaExternalClassSynonym.$type);
}

export interface RosettaExternalEnum extends langium.AstNode {
  readonly $container: RosettaExternalRuleSource | RosettaSynonymSource;
  readonly $type: 'RosettaExternalEnum';
  enumeration: langium.Reference<RosettaEnumeration>;
  regularValues: Array<RosettaExternalEnumValue>;
}

export const RosettaExternalEnum = {
  $type: 'RosettaExternalEnum',
  enumeration: 'enumeration',
  regularValues: 'regularValues'
} as const;

export function isRosettaExternalEnum(item: unknown): item is RosettaExternalEnum {
  return reflection.isInstance(item, RosettaExternalEnum.$type);
}

export interface RosettaExternalEnumValue extends langium.AstNode {
  readonly $container: RosettaExternalEnum;
  readonly $type: 'RosettaExternalEnumValue';
  enumRef: langium.Reference<RosettaEnumValue>;
  externalEnumSynonyms: Array<RosettaEnumSynonym>;
  operator: ExternalValueOperator;
}

export const RosettaExternalEnumValue = {
  $type: 'RosettaExternalEnumValue',
  enumRef: 'enumRef',
  externalEnumSynonyms: 'externalEnumSynonyms',
  operator: 'operator'
} as const;

export function isRosettaExternalEnumValue(item: unknown): item is RosettaExternalEnumValue {
  return reflection.isInstance(item, RosettaExternalEnumValue.$type);
}

export interface RosettaExternalFunction extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaExternalFunction';
  definition?: string;
  name: ValidID;
  parameters: Array<RosettaParameter>;
  typeCall: TypeCall;
}

export const RosettaExternalFunction = {
  $type: 'RosettaExternalFunction',
  definition: 'definition',
  name: 'name',
  parameters: 'parameters',
  typeCall: 'typeCall'
} as const;

export function isRosettaExternalFunction(item: unknown): item is RosettaExternalFunction {
  return reflection.isInstance(item, RosettaExternalFunction.$type);
}

export interface RosettaExternalRegularAttribute extends langium.AstNode {
  readonly $container: RosettaExternalClass;
  readonly $type: 'RosettaExternalRegularAttribute';
  attributeRef: langium.Reference<RosettaFeature>;
  externalRuleReferences: Array<RuleReferenceAnnotation>;
  externalSynonyms: Array<RosettaExternalSynonym>;
  operator: ExternalValueOperator;
}

export const RosettaExternalRegularAttribute = {
  $type: 'RosettaExternalRegularAttribute',
  attributeRef: 'attributeRef',
  externalRuleReferences: 'externalRuleReferences',
  externalSynonyms: 'externalSynonyms',
  operator: 'operator'
} as const;

export function isRosettaExternalRegularAttribute(
  item: unknown
): item is RosettaExternalRegularAttribute {
  return reflection.isInstance(item, RosettaExternalRegularAttribute.$type);
}

export interface RosettaExternalRuleSource extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaExternalRuleSource';
  externalClasses: Array<RosettaExternalClass>;
  externalEnums: Array<RosettaExternalEnum>;
  name: ValidID;
  superSources: Array<langium.Reference<RosettaExternalRuleSource>>;
}

export const RosettaExternalRuleSource = {
  $type: 'RosettaExternalRuleSource',
  externalClasses: 'externalClasses',
  externalEnums: 'externalEnums',
  name: 'name',
  superSources: 'superSources'
} as const;

export function isRosettaExternalRuleSource(item: unknown): item is RosettaExternalRuleSource {
  return reflection.isInstance(item, RosettaExternalRuleSource.$type);
}

export interface RosettaExternalSynonym extends langium.AstNode {
  readonly $container: RosettaExternalRegularAttribute;
  readonly $type: 'RosettaExternalSynonym';
  body: RosettaSynonymBody;
}

export const RosettaExternalSynonym = {
  $type: 'RosettaExternalSynonym',
  body: 'body'
} as const;

export function isRosettaExternalSynonym(item: unknown): item is RosettaExternalSynonym {
  return reflection.isInstance(item, RosettaExternalSynonym.$type);
}

export type RosettaFeature = Attribute | RosettaEnumValue | RosettaMetaType | RosettaRecordFeature;

export const RosettaFeature = {
  $type: 'RosettaFeature'
} as const;

export function isRosettaFeature(item: unknown): item is RosettaFeature {
  return reflection.isInstance(item, RosettaFeature.$type);
}

export interface RosettaFeatureCall extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaFeatureCall';
  feature?: langium.Reference<RosettaFeature>;
  receiver: RosettaExpression;
}

export const RosettaFeatureCall = {
  $type: 'RosettaFeatureCall',
  feature: 'feature',
  receiver: 'receiver'
} as const;

export function isRosettaFeatureCall(item: unknown): item is RosettaFeatureCall {
  return reflection.isInstance(item, RosettaFeatureCall.$type);
}

export interface RosettaFunction extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaFunction';
  annotations: Array<AnnotationRef>;
  conditions: Array<Condition>;
  definition?: string;
  dispatchAttribute?: langium.Reference<Attribute>;
  dispatchValue?: RosettaEnumValueReference;
  inputs: Array<Attribute>;
  name: ValidID;
  operations: Array<Operation>;
  output?: Attribute;
  postConditions: Array<Condition>;
  references: Array<RosettaDocReference>;
  shortcuts: Array<ShortcutDeclaration>;
  superFunction?: langium.Reference<RosettaFunction>;
}

export const RosettaFunction = {
  $type: 'RosettaFunction',
  annotations: 'annotations',
  conditions: 'conditions',
  definition: 'definition',
  dispatchAttribute: 'dispatchAttribute',
  dispatchValue: 'dispatchValue',
  inputs: 'inputs',
  name: 'name',
  operations: 'operations',
  output: 'output',
  postConditions: 'postConditions',
  references: 'references',
  shortcuts: 'shortcuts',
  superFunction: 'superFunction'
} as const;

export function isRosettaFunction(item: unknown): item is RosettaFunction {
  return reflection.isInstance(item, RosettaFunction.$type);
}

export interface RosettaImplicitVariable extends langium.AstNode {
  readonly $container:
    | AnnotationDeepPath
    | AnnotationPath
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LabelAnnotation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaDocReference
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | RuleReferenceAnnotation
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaImplicitVariable';
  name: 'item';
}

export const RosettaImplicitVariable = {
  $type: 'RosettaImplicitVariable',
  name: 'name'
} as const;

export function isRosettaImplicitVariable(item: unknown): item is RosettaImplicitVariable {
  return reflection.isInstance(item, RosettaImplicitVariable.$type);
}

export interface RosettaIntLiteral extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaMapTestEqualityOperation
    | RosettaMappingInstance
    | RosettaMappingPathTests
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseGuard
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaIntLiteral';
  value: Integer;
}

export const RosettaIntLiteral = {
  $type: 'RosettaIntLiteral',
  value: 'value'
} as const;

export function isRosettaIntLiteral(item: unknown): item is RosettaIntLiteral {
  return reflection.isInstance(item, RosettaIntLiteral.$type);
}

export type RosettaLiteral =
  | RosettaBooleanLiteral
  | RosettaIntLiteral
  | RosettaNumberLiteral
  | RosettaStringLiteral;

export const RosettaLiteral = {
  $type: 'RosettaLiteral'
} as const;

export function isRosettaLiteral(item: unknown): item is RosettaLiteral {
  return reflection.isInstance(item, RosettaLiteral.$type);
}

export interface RosettaMapPath extends langium.AstNode {
  readonly $container: RosettaMappingPathTests;
  readonly $type: 'RosettaMapPath';
  path: RosettaMapPathValue;
}

export const RosettaMapPath = {
  $type: 'RosettaMapPath',
  path: 'path'
} as const;

export function isRosettaMapPath(item: unknown): item is RosettaMapPath {
  return reflection.isInstance(item, RosettaMapPath.$type);
}

export interface RosettaMapPathValue extends langium.AstNode {
  readonly $container:
    | RosettaMapPath
    | RosettaMapTestAbsentExpression
    | RosettaMapTestEqualityOperation
    | RosettaMapTestExistsExpression
    | RosettaMapTestFunc
    | RosettaMappingInstance
    | RosettaMappingPathTests;
  readonly $type: 'RosettaMapPathValue';
  path: string;
}

export const RosettaMapPathValue = {
  $type: 'RosettaMapPathValue',
  path: 'path'
} as const;

export function isRosettaMapPathValue(item: unknown): item is RosettaMapPathValue {
  return reflection.isInstance(item, RosettaMapPathValue.$type);
}

export interface RosettaMapping extends langium.AstNode {
  readonly $container: RosettaSynonymBody;
  readonly $type: 'RosettaMapping';
  instances: Array<RosettaMappingInstance>;
}

export const RosettaMapping = {
  $type: 'RosettaMapping',
  instances: 'instances'
} as const;

export function isRosettaMapping(item: unknown): item is RosettaMapping {
  return reflection.isInstance(item, RosettaMapping.$type);
}

export interface RosettaMappingInstance extends langium.AstNode {
  readonly $container: RosettaMapping;
  readonly $type: 'RosettaMappingInstance';
  default: boolean;
  set?: RosettaMapTestExpression;
  when?: RosettaMappingPathTests;
}

export const RosettaMappingInstance = {
  $type: 'RosettaMappingInstance',
  default: 'default',
  set: 'set',
  when: 'when'
} as const;

export function isRosettaMappingInstance(item: unknown): item is RosettaMappingInstance {
  return reflection.isInstance(item, RosettaMappingInstance.$type);
}

export interface RosettaMappingPathTests extends langium.AstNode {
  readonly $container: RosettaMappingInstance;
  readonly $type: 'RosettaMappingPathTests';
  tests: Array<RosettaMapTest>;
}

export const RosettaMappingPathTests = {
  $type: 'RosettaMappingPathTests',
  tests: 'tests'
} as const;

export function isRosettaMappingPathTests(item: unknown): item is RosettaMappingPathTests {
  return reflection.isInstance(item, RosettaMappingPathTests.$type);
}

export interface RosettaMapRosettaPath extends langium.AstNode {
  readonly $container: RosettaMappingPathTests;
  readonly $type: 'RosettaMapRosettaPath';
  path: RosettaAttributeReference;
}

export const RosettaMapRosettaPath = {
  $type: 'RosettaMapRosettaPath',
  path: 'path'
} as const;

export function isRosettaMapRosettaPath(item: unknown): item is RosettaMapRosettaPath {
  return reflection.isInstance(item, RosettaMapRosettaPath.$type);
}

export type RosettaMapTest =
  | RosettaMapPath
  | RosettaMapRosettaPath
  | RosettaMapTestExpression
  | RosettaMapTestFunc;

export const RosettaMapTest = {
  $type: 'RosettaMapTest'
} as const;

export function isRosettaMapTest(item: unknown): item is RosettaMapTest {
  return reflection.isInstance(item, RosettaMapTest.$type);
}

export interface RosettaMapTestAbsentExpression extends langium.AstNode {
  readonly $container:
    | RosettaMapTestEqualityOperation
    | RosettaMappingInstance
    | RosettaMappingPathTests;
  readonly $type: 'RosettaMapTestAbsentExpression';
  argument: RosettaMapPathValue;
}

export const RosettaMapTestAbsentExpression = {
  $type: 'RosettaMapTestAbsentExpression',
  argument: 'argument'
} as const;

export function isRosettaMapTestAbsentExpression(
  item: unknown
): item is RosettaMapTestAbsentExpression {
  return reflection.isInstance(item, RosettaMapTestAbsentExpression.$type);
}

export interface RosettaMapTestEqualityOperation extends langium.AstNode {
  readonly $container:
    | RosettaMapTestEqualityOperation
    | RosettaMappingInstance
    | RosettaMappingPathTests;
  readonly $type: 'RosettaMapTestEqualityOperation';
  left: RosettaMapPathValue;
  operator: '<>' | '=';
  right: RosettaMapTestExpression;
}

export const RosettaMapTestEqualityOperation = {
  $type: 'RosettaMapTestEqualityOperation',
  left: 'left',
  operator: 'operator',
  right: 'right'
} as const;

export function isRosettaMapTestEqualityOperation(
  item: unknown
): item is RosettaMapTestEqualityOperation {
  return reflection.isInstance(item, RosettaMapTestEqualityOperation.$type);
}

export interface RosettaMapTestExistsExpression extends langium.AstNode {
  readonly $container:
    | RosettaMapTestEqualityOperation
    | RosettaMappingInstance
    | RosettaMappingPathTests;
  readonly $type: 'RosettaMapTestExistsExpression';
  argument: RosettaMapPathValue;
}

export const RosettaMapTestExistsExpression = {
  $type: 'RosettaMapTestExistsExpression',
  argument: 'argument'
} as const;

export function isRosettaMapTestExistsExpression(
  item: unknown
): item is RosettaMapTestExistsExpression {
  return reflection.isInstance(item, RosettaMapTestExistsExpression.$type);
}

export type RosettaMapTestExpression =
  | RosettaEnumValueReference
  | RosettaLiteral
  | RosettaMapPathValue
  | RosettaMapTestAbsentExpression
  | RosettaMapTestEqualityOperation
  | RosettaMapTestExistsExpression;

export const RosettaMapTestExpression = {
  $type: 'RosettaMapTestExpression'
} as const;

export function isRosettaMapTestExpression(item: unknown): item is RosettaMapTestExpression {
  return reflection.isInstance(item, RosettaMapTestExpression.$type);
}

export interface RosettaMapTestFunc extends langium.AstNode {
  readonly $container: RosettaMappingPathTests;
  readonly $type: 'RosettaMapTestFunc';
  func: langium.Reference<RosettaCallableWithArgs>;
  predicatePath?: RosettaMapPathValue;
}

export const RosettaMapTestFunc = {
  $type: 'RosettaMapTestFunc',
  func: 'func',
  predicatePath: 'predicatePath'
} as const;

export function isRosettaMapTestFunc(item: unknown): item is RosettaMapTestFunc {
  return reflection.isInstance(item, RosettaMapTestFunc.$type);
}

export interface RosettaMergeSynonymValue extends langium.AstNode {
  readonly $container: RosettaSynonymBody;
  readonly $type: 'RosettaMergeSynonymValue';
  excludePath?: string;
  name: string;
}

export const RosettaMergeSynonymValue = {
  $type: 'RosettaMergeSynonymValue',
  excludePath: 'excludePath',
  name: 'name'
} as const;

export function isRosettaMergeSynonymValue(item: unknown): item is RosettaMergeSynonymValue {
  return reflection.isInstance(item, RosettaMergeSynonymValue.$type);
}

export interface RosettaMetaType extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaMetaType';
  name: ValidID;
  typeCall: TypeCall;
}

export const RosettaMetaType = {
  $type: 'RosettaMetaType',
  name: 'name',
  typeCall: 'typeCall'
} as const;

export function isRosettaMetaType(item: unknown): item is RosettaMetaType {
  return reflection.isInstance(item, RosettaMetaType.$type);
}

export interface RosettaModel extends langium.AstNode {
  readonly $type: 'RosettaModel';
  configurations: Array<RosettaQualifiableConfiguration>;
  definition?: string;
  elements: Array<RosettaRootElement>;
  imports: Array<Import>;
  name: QualifiedName | string;
  overridden: boolean;
  scope?: RosettaScope;
  version?: string;
}

export const RosettaModel = {
  $type: 'RosettaModel',
  configurations: 'configurations',
  definition: 'definition',
  elements: 'elements',
  imports: 'imports',
  name: 'name',
  overridden: 'overridden',
  scope: 'scope',
  version: 'version'
} as const;

export function isRosettaModel(item: unknown): item is RosettaModel {
  return reflection.isInstance(item, RosettaModel.$type);
}

export interface RosettaNumberLiteral extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaMapTestEqualityOperation
    | RosettaMappingInstance
    | RosettaMappingPathTests
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseGuard
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaNumberLiteral';
  value: BigDecimal;
}

export const RosettaNumberLiteral = {
  $type: 'RosettaNumberLiteral',
  value: 'value'
} as const;

export function isRosettaNumberLiteral(item: unknown): item is RosettaNumberLiteral {
  return reflection.isInstance(item, RosettaNumberLiteral.$type);
}

export interface RosettaOnlyElement extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaOnlyElement';
  argument?: RosettaExpression;
  operator: 'only-element';
}

export const RosettaOnlyElement = {
  $type: 'RosettaOnlyElement',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isRosettaOnlyElement(item: unknown): item is RosettaOnlyElement {
  return reflection.isInstance(item, RosettaOnlyElement.$type);
}

export interface RosettaOnlyExistsExpression extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaOnlyExistsExpression';
  args: Array<RosettaExpression>;
  argument?: RosettaExpression;
  operator?: 'exists';
}

export const RosettaOnlyExistsExpression = {
  $type: 'RosettaOnlyExistsExpression',
  args: 'args',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isRosettaOnlyExistsExpression(item: unknown): item is RosettaOnlyExistsExpression {
  return reflection.isInstance(item, RosettaOnlyExistsExpression.$type);
}

export interface RosettaParameter extends langium.AstNode {
  readonly $container: RosettaExternalFunction;
  readonly $type: 'RosettaParameter';
  isArray: boolean;
  name: ValidID;
  typeCall: TypeCall;
}

export const RosettaParameter = {
  $type: 'RosettaParameter',
  isArray: 'isArray',
  name: 'name',
  typeCall: 'typeCall'
} as const;

export function isRosettaParameter(item: unknown): item is RosettaParameter {
  return reflection.isInstance(item, RosettaParameter.$type);
}

export interface RosettaQualifiableConfiguration extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaQualifiableConfiguration';
  qType: RosettaQualifiableType;
  rosettaClass: langium.Reference<Data>;
}

export const RosettaQualifiableConfiguration = {
  $type: 'RosettaQualifiableConfiguration',
  qType: 'qType',
  rosettaClass: 'rosettaClass'
} as const;

export function isRosettaQualifiableConfiguration(
  item: unknown
): item is RosettaQualifiableConfiguration {
  return reflection.isInstance(item, RosettaQualifiableConfiguration.$type);
}

export type RosettaQualifiableType = 'isEvent' | 'isProduct';

export function isRosettaQualifiableType(item: unknown): item is RosettaQualifiableType {
  return item === 'isEvent' || item === 'isProduct';
}

export interface RosettaRecordFeature extends langium.AstNode {
  readonly $container: RosettaRecordType;
  readonly $type: 'RosettaRecordFeature';
  name: ValidID;
  typeCall: TypeCall;
}

export const RosettaRecordFeature = {
  $type: 'RosettaRecordFeature',
  name: 'name',
  typeCall: 'typeCall'
} as const;

export function isRosettaRecordFeature(item: unknown): item is RosettaRecordFeature {
  return reflection.isInstance(item, RosettaRecordFeature.$type);
}

export interface RosettaRecordType extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaRecordType';
  definition?: string;
  features: Array<RosettaRecordFeature>;
  name: ValidID;
}

export const RosettaRecordType = {
  $type: 'RosettaRecordType',
  definition: 'definition',
  features: 'features',
  name: 'name'
} as const;

export function isRosettaRecordType(item: unknown): item is RosettaRecordType {
  return reflection.isInstance(item, RosettaRecordType.$type);
}

export interface RosettaReport extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaReport';
  eligibilityRules: Array<langium.Reference<RosettaRule>>;
  inputType: TypeCall;
  regulatoryBody: RegulatoryDocumentReference;
  reportingStandard?: langium.Reference<RosettaCorpus>;
  reportType: langium.Reference<Data>;
  ruleSource?: langium.Reference<RosettaExternalRuleSource>;
}

export const RosettaReport = {
  $type: 'RosettaReport',
  eligibilityRules: 'eligibilityRules',
  inputType: 'inputType',
  regulatoryBody: 'regulatoryBody',
  reportingStandard: 'reportingStandard',
  reportType: 'reportType',
  ruleSource: 'ruleSource'
} as const;

export function isRosettaReport(item: unknown): item is RosettaReport {
  return reflection.isInstance(item, RosettaReport.$type);
}

export type RosettaRootElement =
  | Annotation
  | Choice
  | Data
  | RosettaBasicType
  | RosettaBody
  | RosettaCorpus
  | RosettaEnumeration
  | RosettaExternalFunction
  | RosettaExternalRuleSource
  | RosettaFunction
  | RosettaMetaType
  | RosettaRecordType
  | RosettaReport
  | RosettaRule
  | RosettaSegment
  | RosettaSynonymSource
  | RosettaTypeAlias;

export const RosettaRootElement = {
  $type: 'RosettaRootElement'
} as const;

export function isRosettaRootElement(item: unknown): item is RosettaRootElement {
  return reflection.isInstance(item, RosettaRootElement.$type);
}

export interface RosettaRule extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaRule';
  definition?: string;
  eligibility: boolean;
  expression: RosettaExpression;
  identifier?: string;
  input?: TypeCall;
  name: ValidID;
  references: Array<RosettaDocReference>;
}

export const RosettaRule = {
  $type: 'RosettaRule',
  definition: 'definition',
  eligibility: 'eligibility',
  expression: 'expression',
  identifier: 'identifier',
  input: 'input',
  name: 'name',
  references: 'references'
} as const;

export function isRosettaRule(item: unknown): item is RosettaRule {
  return reflection.isInstance(item, RosettaRule.$type);
}

export interface RosettaScope extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaScope';
  definition?: string;
  name: ValidID;
}

export const RosettaScope = {
  $type: 'RosettaScope',
  definition: 'definition',
  name: 'name'
} as const;

export function isRosettaScope(item: unknown): item is RosettaScope {
  return reflection.isInstance(item, RosettaScope.$type);
}

export interface RosettaSegment extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaSegment';
  name: 'rationale' | 'rationale_author' | 'structured_provision' | ValidID;
}

export const RosettaSegment = {
  $type: 'RosettaSegment',
  name: 'name'
} as const;

export function isRosettaSegment(item: unknown): item is RosettaSegment {
  return reflection.isInstance(item, RosettaSegment.$type);
}

export interface RosettaSegmentRef extends langium.AstNode {
  readonly $container: RegulatoryDocumentReference;
  readonly $type: 'RosettaSegmentRef';
  segment: langium.Reference<RosettaSegment>;
  segmentRef: string;
}

export const RosettaSegmentRef = {
  $type: 'RosettaSegmentRef',
  segment: 'segment',
  segmentRef: 'segmentRef'
} as const;

export function isRosettaSegmentRef(item: unknown): item is RosettaSegmentRef {
  return reflection.isInstance(item, RosettaSegmentRef.$type);
}

export interface RosettaStringLiteral extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaMapTestEqualityOperation
    | RosettaMappingInstance
    | RosettaMappingPathTests
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseGuard
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaStringLiteral';
  value: string;
}

export const RosettaStringLiteral = {
  $type: 'RosettaStringLiteral',
  value: 'value'
} as const;

export function isRosettaStringLiteral(item: unknown): item is RosettaStringLiteral {
  return reflection.isInstance(item, RosettaStringLiteral.$type);
}

export interface RosettaSuperCall extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaConstructorExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaSuperCall';
  explicitArguments: boolean;
  name: 'super';
  rawArgs: Array<RosettaExpression>;
}

export const RosettaSuperCall = {
  $type: 'RosettaSuperCall',
  explicitArguments: 'explicitArguments',
  name: 'name',
  rawArgs: 'rawArgs'
} as const;

export function isRosettaSuperCall(item: unknown): item is RosettaSuperCall {
  return reflection.isInstance(item, RosettaSuperCall.$type);
}

export type RosettaSymbol =
  | Attribute
  | ClosureParameter
  | RosettaEnumValue
  | RosettaEnumeration
  | RosettaExternalFunction
  | RosettaFunction
  | RosettaMetaType
  | RosettaParameter
  | RosettaRule
  | ShortcutDeclaration
  | TypeParameter;

export const RosettaSymbol = {
  $type: 'RosettaSymbol'
} as const;

export function isRosettaSymbol(item: unknown): item is RosettaSymbol {
  return reflection.isInstance(item, RosettaSymbol.$type);
}

export interface RosettaSymbolReference extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaConstructorExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'RosettaSymbolReference';
  explicitArguments: boolean;
  rawArgs: Array<RosettaExpression>;
  symbol: langium.Reference<RosettaSymbol>;
}

export const RosettaSymbolReference = {
  $type: 'RosettaSymbolReference',
  explicitArguments: 'explicitArguments',
  rawArgs: 'rawArgs',
  symbol: 'symbol'
} as const;

export function isRosettaSymbolReference(item: unknown): item is RosettaSymbolReference {
  return reflection.isInstance(item, RosettaSymbolReference.$type);
}

export interface RosettaSynonym extends langium.AstNode {
  readonly $container: Attribute | ChoiceOption | RosettaEnumeration;
  readonly $type: 'RosettaSynonym';
  body: RosettaSynonymBody;
  sources: Array<langium.Reference<RosettaSynonymSource>>;
}

export const RosettaSynonym = {
  $type: 'RosettaSynonym',
  body: 'body',
  sources: 'sources'
} as const;

export function isRosettaSynonym(item: unknown): item is RosettaSynonym {
  return reflection.isInstance(item, RosettaSynonym.$type);
}

export interface RosettaSynonymBody extends langium.AstNode {
  readonly $container: RosettaExternalSynonym | RosettaSynonym;
  readonly $type: 'RosettaSynonymBody';
  format?: string;
  hints: Array<string>;
  mapper?: string;
  mappingLogic?: RosettaMapping;
  merge?: RosettaMergeSynonymValue;
  metaValues: Array<string>;
  patternMatch?: string;
  patternReplace?: string;
  removeHtml: boolean;
  values: Array<RosettaSynonymValueBase>;
}

export const RosettaSynonymBody = {
  $type: 'RosettaSynonymBody',
  format: 'format',
  hints: 'hints',
  mapper: 'mapper',
  mappingLogic: 'mappingLogic',
  merge: 'merge',
  metaValues: 'metaValues',
  patternMatch: 'patternMatch',
  patternReplace: 'patternReplace',
  removeHtml: 'removeHtml',
  values: 'values'
} as const;

export function isRosettaSynonymBody(item: unknown): item is RosettaSynonymBody {
  return reflection.isInstance(item, RosettaSynonymBody.$type);
}

export type RosettaSynonymRef = 'componentID' | 'tag';

export function isRosettaSynonymRef(item: unknown): item is RosettaSynonymRef {
  return item === 'tag' || item === 'componentID';
}

export interface RosettaSynonymSource extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaSynonymSource';
  externalClasses: Array<RosettaExternalClass>;
  externalEnums: Array<RosettaExternalEnum>;
  name: ValidID;
  superSources: Array<langium.Reference<RosettaSynonymSource>>;
}

export const RosettaSynonymSource = {
  $type: 'RosettaSynonymSource',
  externalClasses: 'externalClasses',
  externalEnums: 'externalEnums',
  name: 'name',
  superSources: 'superSources'
} as const;

export function isRosettaSynonymSource(item: unknown): item is RosettaSynonymSource {
  return reflection.isInstance(item, RosettaSynonymSource.$type);
}

export interface RosettaSynonymValueBase extends langium.AstNode {
  readonly $container: RosettaClassSynonym | RosettaExternalClassSynonym | RosettaSynonymBody;
  readonly $type: 'RosettaSynonymValueBase';
  maps?: number;
  name: string;
  path?: string;
  refType?: RosettaSynonymRef;
  value?: number;
}

export const RosettaSynonymValueBase = {
  $type: 'RosettaSynonymValueBase',
  maps: 'maps',
  name: 'name',
  path: 'path',
  refType: 'refType',
  value: 'value'
} as const;

export function isRosettaSynonymValueBase(item: unknown): item is RosettaSynonymValueBase {
  return reflection.isInstance(item, RosettaSynonymValueBase.$type);
}

export type RosettaType =
  | Choice
  | Data
  | RosettaBasicType
  | RosettaEnumeration
  | RosettaRecordType
  | RosettaTypeAlias;

export const RosettaType = {
  $type: 'RosettaType'
} as const;

export function isRosettaType(item: unknown): item is RosettaType {
  return reflection.isInstance(item, RosettaType.$type);
}

export interface RosettaTypeAlias extends langium.AstNode {
  readonly $container: RosettaModel;
  readonly $type: 'RosettaTypeAlias';
  conditions: Array<Condition>;
  definition?: string;
  name: ValidID;
  parameters: Array<TypeParameter>;
  typeCall: TypeCall;
}

export const RosettaTypeAlias = {
  $type: 'RosettaTypeAlias',
  conditions: 'conditions',
  definition: 'definition',
  name: 'name',
  parameters: 'parameters',
  typeCall: 'typeCall'
} as const;

export function isRosettaTypeAlias(item: unknown): item is RosettaTypeAlias {
  return reflection.isInstance(item, RosettaTypeAlias.$type);
}

export type RosettaTypedFeature = Attribute | RosettaRecordFeature;

export const RosettaTypedFeature = {
  $type: 'RosettaTypedFeature'
} as const;

export function isRosettaTypedFeature(item: unknown): item is RosettaTypedFeature {
  return reflection.isInstance(item, RosettaTypedFeature.$type);
}

export interface RuleReferenceAnnotation extends langium.AstNode {
  readonly $container: Attribute | ChoiceOption | RosettaExternalRegularAttribute;
  readonly $type: 'RuleReferenceAnnotation';
  empty: boolean;
  name: 'ruleReference';
  path?: AnnotationPathExpression;
  reportingRule?: langium.Reference<RosettaRule>;
}

export const RuleReferenceAnnotation = {
  $type: 'RuleReferenceAnnotation',
  empty: 'empty',
  name: 'name',
  path: 'path',
  reportingRule: 'reportingRule'
} as const;

export function isRuleReferenceAnnotation(item: unknown): item is RuleReferenceAnnotation {
  return reflection.isInstance(item, RuleReferenceAnnotation.$type);
}

export interface Segment extends langium.AstNode {
  readonly $container: Operation | Segment;
  readonly $type: 'Segment';
  feature: langium.Reference<RosettaTypedFeature>;
  next?: Segment;
}

export const Segment = {
  $type: 'Segment',
  feature: 'feature',
  next: 'next'
} as const;

export function isSegment(item: unknown): item is Segment {
  return reflection.isInstance(item, Segment.$type);
}

export interface ShortcutDeclaration extends langium.AstNode {
  readonly $container: RosettaFunction;
  readonly $type: 'ShortcutDeclaration';
  definition?: string;
  expression: RosettaExpression;
  name: ValidID;
}

export const ShortcutDeclaration = {
  $type: 'ShortcutDeclaration',
  definition: 'definition',
  expression: 'expression',
  name: 'name'
} as const;

export function isShortcutDeclaration(item: unknown): item is ShortcutDeclaration {
  return reflection.isInstance(item, ShortcutDeclaration.$type);
}

export interface SortOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'SortOperation';
  argument?: RosettaExpression;
  function?: InlineFunction;
  operator: 'sort';
}

export const SortOperation = {
  $type: 'SortOperation',
  argument: 'argument',
  function: 'function',
  operator: 'operator'
} as const;

export function isSortOperation(item: unknown): item is SortOperation {
  return reflection.isInstance(item, SortOperation.$type);
}

export interface SumOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'SumOperation';
  argument?: RosettaExpression;
  operator: 'sum';
}

export const SumOperation = {
  $type: 'SumOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isSumOperation(item: unknown): item is SumOperation {
  return reflection.isInstance(item, SumOperation.$type);
}

export interface SwitchCaseGuard extends langium.AstNode {
  readonly $container: SwitchCaseOrDefault;
  readonly $type: 'SwitchCaseGuard';
  literalGuard?: RosettaLiteral;
  referenceGuard?: langium.Reference<SwitchCaseTarget>;
}

export const SwitchCaseGuard = {
  $type: 'SwitchCaseGuard',
  literalGuard: 'literalGuard',
  referenceGuard: 'referenceGuard'
} as const;

export function isSwitchCaseGuard(item: unknown): item is SwitchCaseGuard {
  return reflection.isInstance(item, SwitchCaseGuard.$type);
}

export interface SwitchCaseOrDefault extends langium.AstNode {
  readonly $container: SwitchOperation;
  readonly $type: 'SwitchCaseOrDefault';
  expression: RosettaExpression;
  guard?: SwitchCaseGuard;
}

export const SwitchCaseOrDefault = {
  $type: 'SwitchCaseOrDefault',
  expression: 'expression',
  guard: 'guard'
} as const;

export function isSwitchCaseOrDefault(item: unknown): item is SwitchCaseOrDefault {
  return reflection.isInstance(item, SwitchCaseOrDefault.$type);
}

export type SwitchCaseTarget = Choice | Data | RosettaEnumValue;

export const SwitchCaseTarget = {
  $type: 'SwitchCaseTarget'
} as const;

export function isSwitchCaseTarget(item: unknown): item is SwitchCaseTarget {
  return reflection.isInstance(item, SwitchCaseTarget.$type);
}

export interface SwitchOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'SwitchOperation';
  argument?: RosettaExpression;
  cases: Array<SwitchCaseOrDefault>;
  operator: 'switch';
}

export const SwitchOperation = {
  $type: 'SwitchOperation',
  argument: 'argument',
  cases: 'cases',
  operator: 'operator'
} as const;

export function isSwitchOperation(item: unknown): item is SwitchOperation {
  return reflection.isInstance(item, SwitchOperation.$type);
}

export interface ThenOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ThenOperation';
  argument: RosettaExpression;
  function?: InlineFunction;
  operator: 'then';
}

export const ThenOperation = {
  $type: 'ThenOperation',
  argument: 'argument',
  function: 'function',
  operator: 'operator'
} as const;

export function isThenOperation(item: unknown): item is ThenOperation {
  return reflection.isInstance(item, ThenOperation.$type);
}

export interface ToDateOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ToDateOperation';
  argument?: RosettaExpression;
  operator: 'to-date';
}

export const ToDateOperation = {
  $type: 'ToDateOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isToDateOperation(item: unknown): item is ToDateOperation {
  return reflection.isInstance(item, ToDateOperation.$type);
}

export interface ToDateTimeOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ToDateTimeOperation';
  argument?: RosettaExpression;
  operator: 'to-date-time';
}

export const ToDateTimeOperation = {
  $type: 'ToDateTimeOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isToDateTimeOperation(item: unknown): item is ToDateTimeOperation {
  return reflection.isInstance(item, ToDateTimeOperation.$type);
}

export interface ToEnumOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ToEnumOperation';
  argument?: RosettaExpression;
  enumeration: langium.Reference<RosettaEnumeration>;
  operator: 'to-enum';
}

export const ToEnumOperation = {
  $type: 'ToEnumOperation',
  argument: 'argument',
  enumeration: 'enumeration',
  operator: 'operator'
} as const;

export function isToEnumOperation(item: unknown): item is ToEnumOperation {
  return reflection.isInstance(item, ToEnumOperation.$type);
}

export interface ToIntOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ToIntOperation';
  argument?: RosettaExpression;
  operator: 'to-int';
}

export const ToIntOperation = {
  $type: 'ToIntOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isToIntOperation(item: unknown): item is ToIntOperation {
  return reflection.isInstance(item, ToIntOperation.$type);
}

export interface ToNumberOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ToNumberOperation';
  argument?: RosettaExpression;
  operator: 'to-number';
}

export const ToNumberOperation = {
  $type: 'ToNumberOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isToNumberOperation(item: unknown): item is ToNumberOperation {
  return reflection.isInstance(item, ToNumberOperation.$type);
}

export interface ToStringOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ToStringOperation';
  argument?: RosettaExpression;
  operator: 'to-string';
}

export const ToStringOperation = {
  $type: 'ToStringOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isToStringOperation(item: unknown): item is ToStringOperation {
  return reflection.isInstance(item, ToStringOperation.$type);
}

export interface ToTimeOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ToTimeOperation';
  argument?: RosettaExpression;
  operator: 'to-time';
}

export const ToTimeOperation = {
  $type: 'ToTimeOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isToTimeOperation(item: unknown): item is ToTimeOperation {
  return reflection.isInstance(item, ToTimeOperation.$type);
}

export interface ToZonedDateTimeOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'ToZonedDateTimeOperation';
  argument?: RosettaExpression;
  operator: 'to-zoned-date-time';
}

export const ToZonedDateTimeOperation = {
  $type: 'ToZonedDateTimeOperation',
  argument: 'argument',
  operator: 'operator'
} as const;

export function isToZonedDateTimeOperation(item: unknown): item is ToZonedDateTimeOperation {
  return reflection.isInstance(item, ToZonedDateTimeOperation.$type);
}

export interface TypeCall extends langium.AstNode {
  readonly $container:
    | Attribute
    | ChoiceOption
    | RosettaExternalFunction
    | RosettaMetaType
    | RosettaParameter
    | RosettaRecordFeature
    | RosettaReport
    | RosettaRule
    | RosettaTypeAlias
    | TypeParameter;
  readonly $type: 'TypeCall';
  arguments: Array<TypeCallArgument>;
  type: langium.Reference<RosettaType>;
}

export const TypeCall = {
  $type: 'TypeCall',
  arguments: 'arguments',
  type: 'type'
} as const;

export function isTypeCall(item: unknown): item is TypeCall {
  return reflection.isInstance(item, TypeCall.$type);
}

export interface TypeCallArgument extends langium.AstNode {
  readonly $container: RosettaConstructorExpression | TypeCall;
  readonly $type: 'TypeCallArgument';
  parameter: langium.Reference<TypeParameter>;
  value: RosettaExpression;
}

export const TypeCallArgument = {
  $type: 'TypeCallArgument',
  parameter: 'parameter',
  value: 'value'
} as const;

export function isTypeCallArgument(item: unknown): item is TypeCallArgument {
  return reflection.isInstance(item, TypeCallArgument.$type);
}

export interface TypeParameter extends langium.AstNode {
  readonly $container: RosettaBasicType | RosettaTypeAlias;
  readonly $type: 'TypeParameter';
  definition?: string;
  name: TypeParameterValidID;
  typeCall: TypeCall;
}

export const TypeParameter = {
  $type: 'TypeParameter',
  definition: 'definition',
  name: 'name',
  typeCall: 'typeCall'
} as const;

export function isTypeParameter(item: unknown): item is TypeParameter {
  return reflection.isInstance(item, TypeParameter.$type);
}

export type TypeParameterValidID = 'max' | 'min' | ValidID;

export function isTypeParameterValidID(item: unknown): item is TypeParameterValidID {
  return isValidID(item) || item === 'min' || item === 'max';
}

export type ValidID = 'condition' | 'pattern' | 'scope' | 'source' | 'value' | 'version' | string;

export function isValidID(item: unknown): item is ValidID {
  return (
    item === 'condition' ||
    item === 'source' ||
    item === 'value' ||
    item === 'version' ||
    item === 'pattern' ||
    item === 'scope' ||
    (typeof item === 'string' && /\^?[a-zA-Z_][a-zA-Z_0-9]*/.test(item))
  );
}

export interface WithMetaEntry extends langium.AstNode {
  readonly $container: WithMetaOperation;
  readonly $type: 'WithMetaEntry';
  key: langium.Reference<RosettaFeature>;
  value: RosettaExpression;
}

export const WithMetaEntry = {
  $type: 'WithMetaEntry',
  key: 'key',
  value: 'value'
} as const;

export function isWithMetaEntry(item: unknown): item is WithMetaEntry {
  return reflection.isInstance(item, WithMetaEntry.$type);
}

export interface WithMetaOperation extends langium.AstNode {
  readonly $container:
    | ArithmeticOperation
    | AsKeyOperation
    | ChoiceOperation
    | ComparisonOperation
    | Condition
    | ConstructorKeyValuePair
    | DefaultOperation
    | DistinctOperation
    | EqualityOperation
    | FilterOperation
    | FirstOperation
    | FlattenOperation
    | InlineFunction
    | JoinOperation
    | LastOperation
    | ListLiteral
    | LogicalOperation
    | MapOperation
    | MaxOperation
    | MinOperation
    | OneOfOperation
    | Operation
    | ReduceOperation
    | ReverseOperation
    | RosettaAbsentExpression
    | RosettaConditionalExpression
    | RosettaContainsExpression
    | RosettaCountOperation
    | RosettaDeepFeatureCall
    | RosettaDisjointExpression
    | RosettaExistsExpression
    | RosettaFeatureCall
    | RosettaOnlyElement
    | RosettaOnlyExistsExpression
    | RosettaRule
    | RosettaSuperCall
    | RosettaSymbolReference
    | ShortcutDeclaration
    | SortOperation
    | SumOperation
    | SwitchCaseOrDefault
    | SwitchOperation
    | ThenOperation
    | ToDateOperation
    | ToDateTimeOperation
    | ToEnumOperation
    | ToIntOperation
    | ToNumberOperation
    | ToStringOperation
    | ToTimeOperation
    | ToZonedDateTimeOperation
    | TypeCallArgument
    | WithMetaEntry
    | WithMetaOperation;
  readonly $type: 'WithMetaOperation';
  argument: RosettaExpression;
  entries: Array<WithMetaEntry>;
  operator: 'with-meta';
}

export const WithMetaOperation = {
  $type: 'WithMetaOperation',
  argument: 'argument',
  entries: 'entries',
  operator: 'operator'
} as const;

export function isWithMetaOperation(item: unknown): item is WithMetaOperation {
  return reflection.isInstance(item, WithMetaOperation.$type);
}

export type RuneDslAstType = {
  Annotation: Annotation;
  AnnotationDeepPath: AnnotationDeepPath;
  AnnotationPath: AnnotationPath;
  AnnotationPathAttributeReference: AnnotationPathAttributeReference;
  AnnotationPathExpression: AnnotationPathExpression;
  AnnotationQualifier: AnnotationQualifier;
  AnnotationRef: AnnotationRef;
  ArithmeticOperation: ArithmeticOperation;
  AsKeyOperation: AsKeyOperation;
  AssignPathRoot: AssignPathRoot;
  Attribute: Attribute;
  Choice: Choice;
  ChoiceOperation: ChoiceOperation;
  ChoiceOption: ChoiceOption;
  ClosureParameter: ClosureParameter;
  ComparisonOperation: ComparisonOperation;
  Condition: Condition;
  ConstructorKeyValuePair: ConstructorKeyValuePair;
  Data: Data;
  DefaultOperation: DefaultOperation;
  DistinctOperation: DistinctOperation;
  DocumentRationale: DocumentRationale;
  EqualityOperation: EqualityOperation;
  FilterOperation: FilterOperation;
  FirstOperation: FirstOperation;
  FlattenOperation: FlattenOperation;
  Import: Import;
  InlineFunction: InlineFunction;
  JoinOperation: JoinOperation;
  LabelAnnotation: LabelAnnotation;
  LastOperation: LastOperation;
  ListLiteral: ListLiteral;
  LogicalOperation: LogicalOperation;
  MapOperation: MapOperation;
  MaxOperation: MaxOperation;
  MinOperation: MinOperation;
  OneOfOperation: OneOfOperation;
  Operation: Operation;
  ReduceOperation: ReduceOperation;
  RegulatoryDocumentReference: RegulatoryDocumentReference;
  ReverseOperation: ReverseOperation;
  RosettaAbsentExpression: RosettaAbsentExpression;
  RosettaAttributeReference: RosettaAttributeReference;
  RosettaBasicType: RosettaBasicType;
  RosettaBody: RosettaBody;
  RosettaBooleanLiteral: RosettaBooleanLiteral;
  RosettaCallableWithArgs: RosettaCallableWithArgs;
  RosettaCardinality: RosettaCardinality;
  RosettaClassSynonym: RosettaClassSynonym;
  RosettaConditionalExpression: RosettaConditionalExpression;
  RosettaConstructorExpression: RosettaConstructorExpression;
  RosettaContainsExpression: RosettaContainsExpression;
  RosettaCorpus: RosettaCorpus;
  RosettaCountOperation: RosettaCountOperation;
  RosettaDataReference: RosettaDataReference;
  RosettaDeepFeatureCall: RosettaDeepFeatureCall;
  RosettaDisjointExpression: RosettaDisjointExpression;
  RosettaDocReference: RosettaDocReference;
  RosettaEnumSynonym: RosettaEnumSynonym;
  RosettaEnumValue: RosettaEnumValue;
  RosettaEnumValueReference: RosettaEnumValueReference;
  RosettaEnumeration: RosettaEnumeration;
  RosettaExistsExpression: RosettaExistsExpression;
  RosettaExpression: RosettaExpression;
  RosettaExternalClass: RosettaExternalClass;
  RosettaExternalClassSynonym: RosettaExternalClassSynonym;
  RosettaExternalEnum: RosettaExternalEnum;
  RosettaExternalEnumValue: RosettaExternalEnumValue;
  RosettaExternalFunction: RosettaExternalFunction;
  RosettaExternalRegularAttribute: RosettaExternalRegularAttribute;
  RosettaExternalRuleSource: RosettaExternalRuleSource;
  RosettaExternalSynonym: RosettaExternalSynonym;
  RosettaFeature: RosettaFeature;
  RosettaFeatureCall: RosettaFeatureCall;
  RosettaFunction: RosettaFunction;
  RosettaImplicitVariable: RosettaImplicitVariable;
  RosettaIntLiteral: RosettaIntLiteral;
  RosettaLiteral: RosettaLiteral;
  RosettaMapPath: RosettaMapPath;
  RosettaMapPathValue: RosettaMapPathValue;
  RosettaMapRosettaPath: RosettaMapRosettaPath;
  RosettaMapTest: RosettaMapTest;
  RosettaMapTestAbsentExpression: RosettaMapTestAbsentExpression;
  RosettaMapTestEqualityOperation: RosettaMapTestEqualityOperation;
  RosettaMapTestExistsExpression: RosettaMapTestExistsExpression;
  RosettaMapTestExpression: RosettaMapTestExpression;
  RosettaMapTestFunc: RosettaMapTestFunc;
  RosettaMapping: RosettaMapping;
  RosettaMappingInstance: RosettaMappingInstance;
  RosettaMappingPathTests: RosettaMappingPathTests;
  RosettaMergeSynonymValue: RosettaMergeSynonymValue;
  RosettaMetaType: RosettaMetaType;
  RosettaModel: RosettaModel;
  RosettaNumberLiteral: RosettaNumberLiteral;
  RosettaOnlyElement: RosettaOnlyElement;
  RosettaOnlyExistsExpression: RosettaOnlyExistsExpression;
  RosettaParameter: RosettaParameter;
  RosettaQualifiableConfiguration: RosettaQualifiableConfiguration;
  RosettaRecordFeature: RosettaRecordFeature;
  RosettaRecordType: RosettaRecordType;
  RosettaReport: RosettaReport;
  RosettaRootElement: RosettaRootElement;
  RosettaRule: RosettaRule;
  RosettaScope: RosettaScope;
  RosettaSegment: RosettaSegment;
  RosettaSegmentRef: RosettaSegmentRef;
  RosettaStringLiteral: RosettaStringLiteral;
  RosettaSuperCall: RosettaSuperCall;
  RosettaSymbol: RosettaSymbol;
  RosettaSymbolReference: RosettaSymbolReference;
  RosettaSynonym: RosettaSynonym;
  RosettaSynonymBody: RosettaSynonymBody;
  RosettaSynonymSource: RosettaSynonymSource;
  RosettaSynonymValueBase: RosettaSynonymValueBase;
  RosettaType: RosettaType;
  RosettaTypeAlias: RosettaTypeAlias;
  RosettaTypedFeature: RosettaTypedFeature;
  RuleReferenceAnnotation: RuleReferenceAnnotation;
  Segment: Segment;
  ShortcutDeclaration: ShortcutDeclaration;
  SortOperation: SortOperation;
  SumOperation: SumOperation;
  SwitchCaseGuard: SwitchCaseGuard;
  SwitchCaseOrDefault: SwitchCaseOrDefault;
  SwitchCaseTarget: SwitchCaseTarget;
  SwitchOperation: SwitchOperation;
  ThenOperation: ThenOperation;
  ToDateOperation: ToDateOperation;
  ToDateTimeOperation: ToDateTimeOperation;
  ToEnumOperation: ToEnumOperation;
  ToIntOperation: ToIntOperation;
  ToNumberOperation: ToNumberOperation;
  ToStringOperation: ToStringOperation;
  ToTimeOperation: ToTimeOperation;
  ToZonedDateTimeOperation: ToZonedDateTimeOperation;
  TypeCall: TypeCall;
  TypeCallArgument: TypeCallArgument;
  TypeParameter: TypeParameter;
  WithMetaEntry: WithMetaEntry;
  WithMetaOperation: WithMetaOperation;
};

export class RuneDslAstReflection extends langium.AbstractAstReflection {
  override readonly types = {
    Annotation: {
      name: Annotation.$type,
      properties: {
        attributes: {
          name: Annotation.attributes,
          defaultValue: []
        },
        definition: {
          name: Annotation.definition
        },
        name: {
          name: Annotation.name
        },
        prefix: {
          name: Annotation.prefix
        }
      },
      superTypes: [RosettaRootElement.$type]
    },
    AnnotationDeepPath: {
      name: AnnotationDeepPath.$type,
      properties: {
        attribute: {
          name: AnnotationDeepPath.attribute,
          referenceType: Attribute.$type
        },
        operator: {
          name: AnnotationDeepPath.operator
        },
        receiver: {
          name: AnnotationDeepPath.receiver
        }
      },
      superTypes: [AnnotationPathExpression.$type]
    },
    AnnotationPath: {
      name: AnnotationPath.$type,
      properties: {
        attribute: {
          name: AnnotationPath.attribute,
          referenceType: Attribute.$type
        },
        operator: {
          name: AnnotationPath.operator
        },
        receiver: {
          name: AnnotationPath.receiver
        }
      },
      superTypes: [AnnotationPathExpression.$type]
    },
    AnnotationPathAttributeReference: {
      name: AnnotationPathAttributeReference.$type,
      properties: {
        attribute: {
          name: AnnotationPathAttributeReference.attribute,
          referenceType: Attribute.$type
        }
      },
      superTypes: [AnnotationPathExpression.$type]
    },
    AnnotationPathExpression: {
      name: AnnotationPathExpression.$type,
      properties: {},
      superTypes: []
    },
    AnnotationQualifier: {
      name: AnnotationQualifier.$type,
      properties: {
        qualName: {
          name: AnnotationQualifier.qualName
        },
        qualPath: {
          name: AnnotationQualifier.qualPath
        },
        qualValue: {
          name: AnnotationQualifier.qualValue
        }
      },
      superTypes: []
    },
    AnnotationRef: {
      name: AnnotationRef.$type,
      properties: {
        annotation: {
          name: AnnotationRef.annotation,
          referenceType: Annotation.$type
        },
        attribute: {
          name: AnnotationRef.attribute,
          referenceType: Attribute.$type
        },
        qualifiers: {
          name: AnnotationRef.qualifiers,
          defaultValue: []
        }
      },
      superTypes: []
    },
    ArithmeticOperation: {
      name: ArithmeticOperation.$type,
      properties: {
        left: {
          name: ArithmeticOperation.left
        },
        operator: {
          name: ArithmeticOperation.operator
        },
        right: {
          name: ArithmeticOperation.right
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    AsKeyOperation: {
      name: AsKeyOperation.$type,
      properties: {
        argument: {
          name: AsKeyOperation.argument
        },
        operator: {
          name: AsKeyOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    AssignPathRoot: {
      name: AssignPathRoot.$type,
      properties: {},
      superTypes: []
    },
    Attribute: {
      name: Attribute.$type,
      properties: {
        annotations: {
          name: Attribute.annotations,
          defaultValue: []
        },
        card: {
          name: Attribute.card
        },
        definition: {
          name: Attribute.definition
        },
        labels: {
          name: Attribute.labels,
          defaultValue: []
        },
        name: {
          name: Attribute.name
        },
        override: {
          name: Attribute.override,
          defaultValue: false
        },
        references: {
          name: Attribute.references,
          defaultValue: []
        },
        ruleReferences: {
          name: Attribute.ruleReferences,
          defaultValue: []
        },
        synonyms: {
          name: Attribute.synonyms,
          defaultValue: []
        },
        typeCall: {
          name: Attribute.typeCall
        }
      },
      superTypes: [
        AssignPathRoot.$type,
        RosettaFeature.$type,
        RosettaSymbol.$type,
        RosettaTypedFeature.$type
      ]
    },
    Choice: {
      name: Choice.$type,
      properties: {
        annotations: {
          name: Choice.annotations,
          defaultValue: []
        },
        attributes: {
          name: Choice.attributes,
          defaultValue: []
        },
        definition: {
          name: Choice.definition
        },
        name: {
          name: Choice.name
        },
        synonyms: {
          name: Choice.synonyms,
          defaultValue: []
        }
      },
      superTypes: [RosettaRootElement.$type, RosettaType.$type, SwitchCaseTarget.$type]
    },
    ChoiceOperation: {
      name: ChoiceOperation.$type,
      properties: {
        argument: {
          name: ChoiceOperation.argument
        },
        attributes: {
          name: ChoiceOperation.attributes,
          defaultValue: [],
          referenceType: Attribute.$type
        },
        necessity: {
          name: ChoiceOperation.necessity
        },
        operator: {
          name: ChoiceOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ChoiceOption: {
      name: ChoiceOption.$type,
      properties: {
        annotations: {
          name: ChoiceOption.annotations,
          defaultValue: []
        },
        definition: {
          name: ChoiceOption.definition
        },
        labels: {
          name: ChoiceOption.labels,
          defaultValue: []
        },
        references: {
          name: ChoiceOption.references,
          defaultValue: []
        },
        ruleReferences: {
          name: ChoiceOption.ruleReferences,
          defaultValue: []
        },
        synonyms: {
          name: ChoiceOption.synonyms,
          defaultValue: []
        },
        typeCall: {
          name: ChoiceOption.typeCall
        }
      },
      superTypes: []
    },
    ClosureParameter: {
      name: ClosureParameter.$type,
      properties: {
        name: {
          name: ClosureParameter.name
        }
      },
      superTypes: [RosettaSymbol.$type]
    },
    ComparisonOperation: {
      name: ComparisonOperation.$type,
      properties: {
        cardMod: {
          name: ComparisonOperation.cardMod
        },
        left: {
          name: ComparisonOperation.left
        },
        operator: {
          name: ComparisonOperation.operator
        },
        right: {
          name: ComparisonOperation.right
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    Condition: {
      name: Condition.$type,
      properties: {
        annotations: {
          name: Condition.annotations,
          defaultValue: []
        },
        definition: {
          name: Condition.definition
        },
        expression: {
          name: Condition.expression
        },
        name: {
          name: Condition.name
        },
        postCondition: {
          name: Condition.postCondition,
          defaultValue: false
        },
        references: {
          name: Condition.references,
          defaultValue: []
        }
      },
      superTypes: []
    },
    ConstructorKeyValuePair: {
      name: ConstructorKeyValuePair.$type,
      properties: {
        key: {
          name: ConstructorKeyValuePair.key,
          referenceType: RosettaFeature.$type
        },
        value: {
          name: ConstructorKeyValuePair.value
        }
      },
      superTypes: []
    },
    Data: {
      name: Data.$type,
      properties: {
        annotations: {
          name: Data.annotations,
          defaultValue: []
        },
        attributes: {
          name: Data.attributes,
          defaultValue: []
        },
        conditions: {
          name: Data.conditions,
          defaultValue: []
        },
        definition: {
          name: Data.definition
        },
        name: {
          name: Data.name
        },
        references: {
          name: Data.references,
          defaultValue: []
        },
        superType: {
          name: Data.superType,
          referenceType: Data.$type
        },
        synonyms: {
          name: Data.synonyms,
          defaultValue: []
        }
      },
      superTypes: [RosettaRootElement.$type, RosettaType.$type, SwitchCaseTarget.$type]
    },
    DefaultOperation: {
      name: DefaultOperation.$type,
      properties: {
        left: {
          name: DefaultOperation.left
        },
        operator: {
          name: DefaultOperation.operator
        },
        right: {
          name: DefaultOperation.right
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    DistinctOperation: {
      name: DistinctOperation.$type,
      properties: {
        argument: {
          name: DistinctOperation.argument
        },
        operator: {
          name: DistinctOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    DocumentRationale: {
      name: DocumentRationale.$type,
      properties: {
        rationale: {
          name: DocumentRationale.rationale
        },
        rationaleAuthor: {
          name: DocumentRationale.rationaleAuthor
        }
      },
      superTypes: []
    },
    EqualityOperation: {
      name: EqualityOperation.$type,
      properties: {
        cardMod: {
          name: EqualityOperation.cardMod
        },
        left: {
          name: EqualityOperation.left
        },
        operator: {
          name: EqualityOperation.operator
        },
        right: {
          name: EqualityOperation.right
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    FilterOperation: {
      name: FilterOperation.$type,
      properties: {
        argument: {
          name: FilterOperation.argument
        },
        function: {
          name: FilterOperation.function
        },
        operator: {
          name: FilterOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    FirstOperation: {
      name: FirstOperation.$type,
      properties: {
        argument: {
          name: FirstOperation.argument
        },
        operator: {
          name: FirstOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    FlattenOperation: {
      name: FlattenOperation.$type,
      properties: {
        argument: {
          name: FlattenOperation.argument
        },
        operator: {
          name: FlattenOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    Import: {
      name: Import.$type,
      properties: {
        importedNamespace: {
          name: Import.importedNamespace
        },
        namespaceAlias: {
          name: Import.namespaceAlias
        }
      },
      superTypes: []
    },
    InlineFunction: {
      name: InlineFunction.$type,
      properties: {
        body: {
          name: InlineFunction.body
        },
        parameters: {
          name: InlineFunction.parameters,
          defaultValue: []
        }
      },
      superTypes: []
    },
    JoinOperation: {
      name: JoinOperation.$type,
      properties: {
        left: {
          name: JoinOperation.left
        },
        operator: {
          name: JoinOperation.operator
        },
        right: {
          name: JoinOperation.right
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    LabelAnnotation: {
      name: LabelAnnotation.$type,
      properties: {
        deprecatedAs: {
          name: LabelAnnotation.deprecatedAs,
          defaultValue: false
        },
        label: {
          name: LabelAnnotation.label
        },
        name: {
          name: LabelAnnotation.name
        },
        path: {
          name: LabelAnnotation.path
        }
      },
      superTypes: []
    },
    LastOperation: {
      name: LastOperation.$type,
      properties: {
        argument: {
          name: LastOperation.argument
        },
        operator: {
          name: LastOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ListLiteral: {
      name: ListLiteral.$type,
      properties: {
        elements: {
          name: ListLiteral.elements,
          defaultValue: []
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    LogicalOperation: {
      name: LogicalOperation.$type,
      properties: {
        left: {
          name: LogicalOperation.left
        },
        operator: {
          name: LogicalOperation.operator
        },
        right: {
          name: LogicalOperation.right
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    MapOperation: {
      name: MapOperation.$type,
      properties: {
        argument: {
          name: MapOperation.argument
        },
        function: {
          name: MapOperation.function
        },
        operator: {
          name: MapOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    MaxOperation: {
      name: MaxOperation.$type,
      properties: {
        argument: {
          name: MaxOperation.argument
        },
        function: {
          name: MaxOperation.function
        },
        operator: {
          name: MaxOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    MinOperation: {
      name: MinOperation.$type,
      properties: {
        argument: {
          name: MinOperation.argument
        },
        function: {
          name: MinOperation.function
        },
        operator: {
          name: MinOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    OneOfOperation: {
      name: OneOfOperation.$type,
      properties: {
        argument: {
          name: OneOfOperation.argument
        },
        operator: {
          name: OneOfOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    Operation: {
      name: Operation.$type,
      properties: {
        add: {
          name: Operation.add,
          defaultValue: false
        },
        assignRoot: {
          name: Operation.assignRoot,
          referenceType: AssignPathRoot.$type
        },
        definition: {
          name: Operation.definition
        },
        expression: {
          name: Operation.expression
        },
        path: {
          name: Operation.path
        }
      },
      superTypes: []
    },
    ReduceOperation: {
      name: ReduceOperation.$type,
      properties: {
        argument: {
          name: ReduceOperation.argument
        },
        function: {
          name: ReduceOperation.function
        },
        operator: {
          name: ReduceOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RegulatoryDocumentReference: {
      name: RegulatoryDocumentReference.$type,
      properties: {
        body: {
          name: RegulatoryDocumentReference.body,
          referenceType: RosettaBody.$type
        },
        corpusList: {
          name: RegulatoryDocumentReference.corpusList,
          defaultValue: [],
          referenceType: RosettaCorpus.$type
        },
        segments: {
          name: RegulatoryDocumentReference.segments,
          defaultValue: []
        }
      },
      superTypes: []
    },
    ReverseOperation: {
      name: ReverseOperation.$type,
      properties: {
        argument: {
          name: ReverseOperation.argument
        },
        operator: {
          name: ReverseOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaAbsentExpression: {
      name: RosettaAbsentExpression.$type,
      properties: {
        argument: {
          name: RosettaAbsentExpression.argument
        },
        operator: {
          name: RosettaAbsentExpression.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaAttributeReference: {
      name: RosettaAttributeReference.$type,
      properties: {
        attribute: {
          name: RosettaAttributeReference.attribute,
          referenceType: Attribute.$type
        },
        receiver: {
          name: RosettaAttributeReference.receiver
        }
      },
      superTypes: []
    },
    RosettaBasicType: {
      name: RosettaBasicType.$type,
      properties: {
        definition: {
          name: RosettaBasicType.definition
        },
        name: {
          name: RosettaBasicType.name
        },
        parameters: {
          name: RosettaBasicType.parameters,
          defaultValue: []
        }
      },
      superTypes: [RosettaRootElement.$type, RosettaType.$type]
    },
    RosettaBody: {
      name: RosettaBody.$type,
      properties: {
        bodyType: {
          name: RosettaBody.bodyType
        },
        definition: {
          name: RosettaBody.definition
        },
        name: {
          name: RosettaBody.name
        }
      },
      superTypes: [RosettaRootElement.$type]
    },
    RosettaBooleanLiteral: {
      name: RosettaBooleanLiteral.$type,
      properties: {
        value: {
          name: RosettaBooleanLiteral.value,
          defaultValue: false
        }
      },
      superTypes: [RosettaLiteral.$type]
    },
    RosettaCallableWithArgs: {
      name: RosettaCallableWithArgs.$type,
      properties: {},
      superTypes: []
    },
    RosettaCardinality: {
      name: RosettaCardinality.$type,
      properties: {
        inf: {
          name: RosettaCardinality.inf
        },
        sup: {
          name: RosettaCardinality.sup
        },
        unbounded: {
          name: RosettaCardinality.unbounded,
          defaultValue: false
        }
      },
      superTypes: []
    },
    RosettaClassSynonym: {
      name: RosettaClassSynonym.$type,
      properties: {
        metaValue: {
          name: RosettaClassSynonym.metaValue
        },
        sources: {
          name: RosettaClassSynonym.sources,
          defaultValue: [],
          referenceType: RosettaSynonymSource.$type
        },
        value: {
          name: RosettaClassSynonym.value
        }
      },
      superTypes: []
    },
    RosettaConditionalExpression: {
      name: RosettaConditionalExpression.$type,
      properties: {
        elsethen: {
          name: RosettaConditionalExpression.elsethen
        },
        full: {
          name: RosettaConditionalExpression.full,
          defaultValue: false
        },
        if: {
          name: RosettaConditionalExpression.if
        },
        ifthen: {
          name: RosettaConditionalExpression.ifthen
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaConstructorExpression: {
      name: RosettaConstructorExpression.$type,
      properties: {
        constructorTypeArgs: {
          name: RosettaConstructorExpression.constructorTypeArgs,
          defaultValue: []
        },
        implicitEmpty: {
          name: RosettaConstructorExpression.implicitEmpty,
          defaultValue: false
        },
        typeRef: {
          name: RosettaConstructorExpression.typeRef
        },
        values: {
          name: RosettaConstructorExpression.values,
          defaultValue: []
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaContainsExpression: {
      name: RosettaContainsExpression.$type,
      properties: {
        left: {
          name: RosettaContainsExpression.left
        },
        operator: {
          name: RosettaContainsExpression.operator
        },
        right: {
          name: RosettaContainsExpression.right
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaCorpus: {
      name: RosettaCorpus.$type,
      properties: {
        body: {
          name: RosettaCorpus.body,
          referenceType: RosettaBody.$type
        },
        corpusType: {
          name: RosettaCorpus.corpusType
        },
        definition: {
          name: RosettaCorpus.definition
        },
        displayName: {
          name: RosettaCorpus.displayName
        },
        name: {
          name: RosettaCorpus.name
        }
      },
      superTypes: [RosettaRootElement.$type]
    },
    RosettaCountOperation: {
      name: RosettaCountOperation.$type,
      properties: {
        argument: {
          name: RosettaCountOperation.argument
        },
        operator: {
          name: RosettaCountOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaDataReference: {
      name: RosettaDataReference.$type,
      properties: {
        attribute: {
          name: RosettaDataReference.attribute,
          referenceType: Attribute.$type
        },
        data: {
          name: RosettaDataReference.data,
          referenceType: Data.$type
        },
        receiver: {
          name: RosettaDataReference.receiver
        }
      },
      superTypes: [RosettaAttributeReference.$type]
    },
    RosettaDeepFeatureCall: {
      name: RosettaDeepFeatureCall.$type,
      properties: {
        feature: {
          name: RosettaDeepFeatureCall.feature,
          referenceType: Attribute.$type
        },
        receiver: {
          name: RosettaDeepFeatureCall.receiver
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaDisjointExpression: {
      name: RosettaDisjointExpression.$type,
      properties: {
        left: {
          name: RosettaDisjointExpression.left
        },
        operator: {
          name: RosettaDisjointExpression.operator
        },
        right: {
          name: RosettaDisjointExpression.right
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaDocReference: {
      name: RosettaDocReference.$type,
      properties: {
        docReference: {
          name: RosettaDocReference.docReference
        },
        name: {
          name: RosettaDocReference.name
        },
        path: {
          name: RosettaDocReference.path
        },
        provision: {
          name: RosettaDocReference.provision
        },
        rationales: {
          name: RosettaDocReference.rationales,
          defaultValue: []
        },
        reportedField: {
          name: RosettaDocReference.reportedField,
          defaultValue: false
        },
        structuredProvision: {
          name: RosettaDocReference.structuredProvision
        }
      },
      superTypes: []
    },
    RosettaEnumSynonym: {
      name: RosettaEnumSynonym.$type,
      properties: {
        definition: {
          name: RosettaEnumSynonym.definition
        },
        patternMatch: {
          name: RosettaEnumSynonym.patternMatch
        },
        patternReplace: {
          name: RosettaEnumSynonym.patternReplace
        },
        removeHtml: {
          name: RosettaEnumSynonym.removeHtml,
          defaultValue: false
        },
        sources: {
          name: RosettaEnumSynonym.sources,
          defaultValue: [],
          referenceType: RosettaSynonymSource.$type
        },
        synonymValue: {
          name: RosettaEnumSynonym.synonymValue
        }
      },
      superTypes: []
    },
    RosettaEnumValue: {
      name: RosettaEnumValue.$type,
      properties: {
        annotations: {
          name: RosettaEnumValue.annotations,
          defaultValue: []
        },
        definition: {
          name: RosettaEnumValue.definition
        },
        display: {
          name: RosettaEnumValue.display
        },
        enumSynonyms: {
          name: RosettaEnumValue.enumSynonyms,
          defaultValue: []
        },
        name: {
          name: RosettaEnumValue.name
        },
        references: {
          name: RosettaEnumValue.references,
          defaultValue: []
        }
      },
      superTypes: [RosettaFeature.$type, RosettaSymbol.$type, SwitchCaseTarget.$type]
    },
    RosettaEnumValueReference: {
      name: RosettaEnumValueReference.$type,
      properties: {
        enumeration: {
          name: RosettaEnumValueReference.enumeration,
          referenceType: RosettaEnumeration.$type
        },
        value: {
          name: RosettaEnumValueReference.value,
          referenceType: RosettaEnumValue.$type
        }
      },
      superTypes: [RosettaMapTestExpression.$type]
    },
    RosettaEnumeration: {
      name: RosettaEnumeration.$type,
      properties: {
        annotations: {
          name: RosettaEnumeration.annotations,
          defaultValue: []
        },
        definition: {
          name: RosettaEnumeration.definition
        },
        enumValues: {
          name: RosettaEnumeration.enumValues,
          defaultValue: []
        },
        name: {
          name: RosettaEnumeration.name
        },
        parent: {
          name: RosettaEnumeration.parent,
          referenceType: RosettaEnumeration.$type
        },
        references: {
          name: RosettaEnumeration.references,
          defaultValue: []
        },
        synonyms: {
          name: RosettaEnumeration.synonyms,
          defaultValue: []
        }
      },
      superTypes: [RosettaRootElement.$type, RosettaSymbol.$type, RosettaType.$type]
    },
    RosettaExistsExpression: {
      name: RosettaExistsExpression.$type,
      properties: {
        argument: {
          name: RosettaExistsExpression.argument
        },
        modifier: {
          name: RosettaExistsExpression.modifier
        },
        operator: {
          name: RosettaExistsExpression.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaExpression: {
      name: RosettaExpression.$type,
      properties: {},
      superTypes: []
    },
    RosettaExternalClass: {
      name: RosettaExternalClass.$type,
      properties: {
        data: {
          name: RosettaExternalClass.data,
          referenceType: Data.$type
        },
        externalClassSynonyms: {
          name: RosettaExternalClass.externalClassSynonyms,
          defaultValue: []
        },
        regularAttributes: {
          name: RosettaExternalClass.regularAttributes,
          defaultValue: []
        }
      },
      superTypes: []
    },
    RosettaExternalClassSynonym: {
      name: RosettaExternalClassSynonym.$type,
      properties: {
        metaValue: {
          name: RosettaExternalClassSynonym.metaValue
        },
        value: {
          name: RosettaExternalClassSynonym.value
        }
      },
      superTypes: []
    },
    RosettaExternalEnum: {
      name: RosettaExternalEnum.$type,
      properties: {
        enumeration: {
          name: RosettaExternalEnum.enumeration,
          referenceType: RosettaEnumeration.$type
        },
        regularValues: {
          name: RosettaExternalEnum.regularValues,
          defaultValue: []
        }
      },
      superTypes: []
    },
    RosettaExternalEnumValue: {
      name: RosettaExternalEnumValue.$type,
      properties: {
        enumRef: {
          name: RosettaExternalEnumValue.enumRef,
          referenceType: RosettaEnumValue.$type
        },
        externalEnumSynonyms: {
          name: RosettaExternalEnumValue.externalEnumSynonyms,
          defaultValue: []
        },
        operator: {
          name: RosettaExternalEnumValue.operator
        }
      },
      superTypes: []
    },
    RosettaExternalFunction: {
      name: RosettaExternalFunction.$type,
      properties: {
        definition: {
          name: RosettaExternalFunction.definition
        },
        name: {
          name: RosettaExternalFunction.name
        },
        parameters: {
          name: RosettaExternalFunction.parameters,
          defaultValue: []
        },
        typeCall: {
          name: RosettaExternalFunction.typeCall
        }
      },
      superTypes: [RosettaCallableWithArgs.$type, RosettaRootElement.$type, RosettaSymbol.$type]
    },
    RosettaExternalRegularAttribute: {
      name: RosettaExternalRegularAttribute.$type,
      properties: {
        attributeRef: {
          name: RosettaExternalRegularAttribute.attributeRef,
          referenceType: RosettaFeature.$type
        },
        externalRuleReferences: {
          name: RosettaExternalRegularAttribute.externalRuleReferences,
          defaultValue: []
        },
        externalSynonyms: {
          name: RosettaExternalRegularAttribute.externalSynonyms,
          defaultValue: []
        },
        operator: {
          name: RosettaExternalRegularAttribute.operator
        }
      },
      superTypes: []
    },
    RosettaExternalRuleSource: {
      name: RosettaExternalRuleSource.$type,
      properties: {
        externalClasses: {
          name: RosettaExternalRuleSource.externalClasses,
          defaultValue: []
        },
        externalEnums: {
          name: RosettaExternalRuleSource.externalEnums,
          defaultValue: []
        },
        name: {
          name: RosettaExternalRuleSource.name
        },
        superSources: {
          name: RosettaExternalRuleSource.superSources,
          defaultValue: [],
          referenceType: RosettaExternalRuleSource.$type
        }
      },
      superTypes: [RosettaRootElement.$type]
    },
    RosettaExternalSynonym: {
      name: RosettaExternalSynonym.$type,
      properties: {
        body: {
          name: RosettaExternalSynonym.body
        }
      },
      superTypes: []
    },
    RosettaFeature: {
      name: RosettaFeature.$type,
      properties: {},
      superTypes: []
    },
    RosettaFeatureCall: {
      name: RosettaFeatureCall.$type,
      properties: {
        feature: {
          name: RosettaFeatureCall.feature,
          referenceType: RosettaFeature.$type
        },
        receiver: {
          name: RosettaFeatureCall.receiver
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaFunction: {
      name: RosettaFunction.$type,
      properties: {
        annotations: {
          name: RosettaFunction.annotations,
          defaultValue: []
        },
        conditions: {
          name: RosettaFunction.conditions,
          defaultValue: []
        },
        definition: {
          name: RosettaFunction.definition
        },
        dispatchAttribute: {
          name: RosettaFunction.dispatchAttribute,
          referenceType: Attribute.$type
        },
        dispatchValue: {
          name: RosettaFunction.dispatchValue
        },
        inputs: {
          name: RosettaFunction.inputs,
          defaultValue: []
        },
        name: {
          name: RosettaFunction.name
        },
        operations: {
          name: RosettaFunction.operations,
          defaultValue: []
        },
        output: {
          name: RosettaFunction.output
        },
        postConditions: {
          name: RosettaFunction.postConditions,
          defaultValue: []
        },
        references: {
          name: RosettaFunction.references,
          defaultValue: []
        },
        shortcuts: {
          name: RosettaFunction.shortcuts,
          defaultValue: []
        },
        superFunction: {
          name: RosettaFunction.superFunction,
          referenceType: RosettaFunction.$type
        }
      },
      superTypes: [RosettaCallableWithArgs.$type, RosettaRootElement.$type, RosettaSymbol.$type]
    },
    RosettaImplicitVariable: {
      name: RosettaImplicitVariable.$type,
      properties: {
        name: {
          name: RosettaImplicitVariable.name
        }
      },
      superTypes: [AnnotationPathExpression.$type, RosettaExpression.$type]
    },
    RosettaIntLiteral: {
      name: RosettaIntLiteral.$type,
      properties: {
        value: {
          name: RosettaIntLiteral.value
        }
      },
      superTypes: [RosettaLiteral.$type]
    },
    RosettaLiteral: {
      name: RosettaLiteral.$type,
      properties: {},
      superTypes: [RosettaExpression.$type, RosettaMapTestExpression.$type]
    },
    RosettaMapPath: {
      name: RosettaMapPath.$type,
      properties: {
        path: {
          name: RosettaMapPath.path
        }
      },
      superTypes: [RosettaMapTest.$type]
    },
    RosettaMapPathValue: {
      name: RosettaMapPathValue.$type,
      properties: {
        path: {
          name: RosettaMapPathValue.path
        }
      },
      superTypes: [RosettaMapTestExpression.$type]
    },
    RosettaMapRosettaPath: {
      name: RosettaMapRosettaPath.$type,
      properties: {
        path: {
          name: RosettaMapRosettaPath.path
        }
      },
      superTypes: [RosettaMapTest.$type]
    },
    RosettaMapTest: {
      name: RosettaMapTest.$type,
      properties: {},
      superTypes: []
    },
    RosettaMapTestAbsentExpression: {
      name: RosettaMapTestAbsentExpression.$type,
      properties: {
        argument: {
          name: RosettaMapTestAbsentExpression.argument
        }
      },
      superTypes: [RosettaMapTestExpression.$type]
    },
    RosettaMapTestEqualityOperation: {
      name: RosettaMapTestEqualityOperation.$type,
      properties: {
        left: {
          name: RosettaMapTestEqualityOperation.left
        },
        operator: {
          name: RosettaMapTestEqualityOperation.operator
        },
        right: {
          name: RosettaMapTestEqualityOperation.right
        }
      },
      superTypes: [RosettaMapTestExpression.$type]
    },
    RosettaMapTestExistsExpression: {
      name: RosettaMapTestExistsExpression.$type,
      properties: {
        argument: {
          name: RosettaMapTestExistsExpression.argument
        }
      },
      superTypes: [RosettaMapTestExpression.$type]
    },
    RosettaMapTestExpression: {
      name: RosettaMapTestExpression.$type,
      properties: {},
      superTypes: [RosettaMapTest.$type]
    },
    RosettaMapTestFunc: {
      name: RosettaMapTestFunc.$type,
      properties: {
        func: {
          name: RosettaMapTestFunc.func,
          referenceType: RosettaCallableWithArgs.$type
        },
        predicatePath: {
          name: RosettaMapTestFunc.predicatePath
        }
      },
      superTypes: [RosettaMapTest.$type]
    },
    RosettaMapping: {
      name: RosettaMapping.$type,
      properties: {
        instances: {
          name: RosettaMapping.instances,
          defaultValue: []
        }
      },
      superTypes: []
    },
    RosettaMappingInstance: {
      name: RosettaMappingInstance.$type,
      properties: {
        default: {
          name: RosettaMappingInstance.default,
          defaultValue: false
        },
        set: {
          name: RosettaMappingInstance.set
        },
        when: {
          name: RosettaMappingInstance.when
        }
      },
      superTypes: []
    },
    RosettaMappingPathTests: {
      name: RosettaMappingPathTests.$type,
      properties: {
        tests: {
          name: RosettaMappingPathTests.tests,
          defaultValue: []
        }
      },
      superTypes: []
    },
    RosettaMergeSynonymValue: {
      name: RosettaMergeSynonymValue.$type,
      properties: {
        excludePath: {
          name: RosettaMergeSynonymValue.excludePath
        },
        name: {
          name: RosettaMergeSynonymValue.name
        }
      },
      superTypes: []
    },
    RosettaMetaType: {
      name: RosettaMetaType.$type,
      properties: {
        name: {
          name: RosettaMetaType.name
        },
        typeCall: {
          name: RosettaMetaType.typeCall
        }
      },
      superTypes: [RosettaFeature.$type, RosettaRootElement.$type, RosettaSymbol.$type]
    },
    RosettaModel: {
      name: RosettaModel.$type,
      properties: {
        configurations: {
          name: RosettaModel.configurations,
          defaultValue: []
        },
        definition: {
          name: RosettaModel.definition
        },
        elements: {
          name: RosettaModel.elements,
          defaultValue: []
        },
        imports: {
          name: RosettaModel.imports,
          defaultValue: []
        },
        name: {
          name: RosettaModel.name
        },
        overridden: {
          name: RosettaModel.overridden,
          defaultValue: false
        },
        scope: {
          name: RosettaModel.scope
        },
        version: {
          name: RosettaModel.version
        }
      },
      superTypes: []
    },
    RosettaNumberLiteral: {
      name: RosettaNumberLiteral.$type,
      properties: {
        value: {
          name: RosettaNumberLiteral.value
        }
      },
      superTypes: [RosettaLiteral.$type]
    },
    RosettaOnlyElement: {
      name: RosettaOnlyElement.$type,
      properties: {
        argument: {
          name: RosettaOnlyElement.argument
        },
        operator: {
          name: RosettaOnlyElement.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaOnlyExistsExpression: {
      name: RosettaOnlyExistsExpression.$type,
      properties: {
        args: {
          name: RosettaOnlyExistsExpression.args,
          defaultValue: []
        },
        argument: {
          name: RosettaOnlyExistsExpression.argument
        },
        operator: {
          name: RosettaOnlyExistsExpression.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaParameter: {
      name: RosettaParameter.$type,
      properties: {
        isArray: {
          name: RosettaParameter.isArray,
          defaultValue: false
        },
        name: {
          name: RosettaParameter.name
        },
        typeCall: {
          name: RosettaParameter.typeCall
        }
      },
      superTypes: [RosettaSymbol.$type]
    },
    RosettaQualifiableConfiguration: {
      name: RosettaQualifiableConfiguration.$type,
      properties: {
        qType: {
          name: RosettaQualifiableConfiguration.qType
        },
        rosettaClass: {
          name: RosettaQualifiableConfiguration.rosettaClass,
          referenceType: Data.$type
        }
      },
      superTypes: []
    },
    RosettaRecordFeature: {
      name: RosettaRecordFeature.$type,
      properties: {
        name: {
          name: RosettaRecordFeature.name
        },
        typeCall: {
          name: RosettaRecordFeature.typeCall
        }
      },
      superTypes: [RosettaFeature.$type, RosettaTypedFeature.$type]
    },
    RosettaRecordType: {
      name: RosettaRecordType.$type,
      properties: {
        definition: {
          name: RosettaRecordType.definition
        },
        features: {
          name: RosettaRecordType.features,
          defaultValue: []
        },
        name: {
          name: RosettaRecordType.name
        }
      },
      superTypes: [RosettaRootElement.$type, RosettaType.$type]
    },
    RosettaReport: {
      name: RosettaReport.$type,
      properties: {
        eligibilityRules: {
          name: RosettaReport.eligibilityRules,
          defaultValue: [],
          referenceType: RosettaRule.$type
        },
        inputType: {
          name: RosettaReport.inputType
        },
        regulatoryBody: {
          name: RosettaReport.regulatoryBody
        },
        reportingStandard: {
          name: RosettaReport.reportingStandard,
          referenceType: RosettaCorpus.$type
        },
        reportType: {
          name: RosettaReport.reportType,
          referenceType: Data.$type
        },
        ruleSource: {
          name: RosettaReport.ruleSource,
          referenceType: RosettaExternalRuleSource.$type
        }
      },
      superTypes: [RosettaRootElement.$type]
    },
    RosettaRootElement: {
      name: RosettaRootElement.$type,
      properties: {},
      superTypes: []
    },
    RosettaRule: {
      name: RosettaRule.$type,
      properties: {
        definition: {
          name: RosettaRule.definition
        },
        eligibility: {
          name: RosettaRule.eligibility,
          defaultValue: false
        },
        expression: {
          name: RosettaRule.expression
        },
        identifier: {
          name: RosettaRule.identifier
        },
        input: {
          name: RosettaRule.input
        },
        name: {
          name: RosettaRule.name
        },
        references: {
          name: RosettaRule.references,
          defaultValue: []
        }
      },
      superTypes: [RosettaCallableWithArgs.$type, RosettaRootElement.$type, RosettaSymbol.$type]
    },
    RosettaScope: {
      name: RosettaScope.$type,
      properties: {
        definition: {
          name: RosettaScope.definition
        },
        name: {
          name: RosettaScope.name
        }
      },
      superTypes: []
    },
    RosettaSegment: {
      name: RosettaSegment.$type,
      properties: {
        name: {
          name: RosettaSegment.name
        }
      },
      superTypes: [RosettaRootElement.$type]
    },
    RosettaSegmentRef: {
      name: RosettaSegmentRef.$type,
      properties: {
        segment: {
          name: RosettaSegmentRef.segment,
          referenceType: RosettaSegment.$type
        },
        segmentRef: {
          name: RosettaSegmentRef.segmentRef
        }
      },
      superTypes: []
    },
    RosettaStringLiteral: {
      name: RosettaStringLiteral.$type,
      properties: {
        value: {
          name: RosettaStringLiteral.value
        }
      },
      superTypes: [RosettaLiteral.$type]
    },
    RosettaSuperCall: {
      name: RosettaSuperCall.$type,
      properties: {
        explicitArguments: {
          name: RosettaSuperCall.explicitArguments,
          defaultValue: false
        },
        name: {
          name: RosettaSuperCall.name
        },
        rawArgs: {
          name: RosettaSuperCall.rawArgs,
          defaultValue: []
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaSymbol: {
      name: RosettaSymbol.$type,
      properties: {},
      superTypes: []
    },
    RosettaSymbolReference: {
      name: RosettaSymbolReference.$type,
      properties: {
        explicitArguments: {
          name: RosettaSymbolReference.explicitArguments,
          defaultValue: false
        },
        rawArgs: {
          name: RosettaSymbolReference.rawArgs,
          defaultValue: []
        },
        symbol: {
          name: RosettaSymbolReference.symbol,
          referenceType: RosettaSymbol.$type
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    RosettaSynonym: {
      name: RosettaSynonym.$type,
      properties: {
        body: {
          name: RosettaSynonym.body
        },
        sources: {
          name: RosettaSynonym.sources,
          defaultValue: [],
          referenceType: RosettaSynonymSource.$type
        }
      },
      superTypes: []
    },
    RosettaSynonymBody: {
      name: RosettaSynonymBody.$type,
      properties: {
        format: {
          name: RosettaSynonymBody.format
        },
        hints: {
          name: RosettaSynonymBody.hints,
          defaultValue: []
        },
        mapper: {
          name: RosettaSynonymBody.mapper
        },
        mappingLogic: {
          name: RosettaSynonymBody.mappingLogic
        },
        merge: {
          name: RosettaSynonymBody.merge
        },
        metaValues: {
          name: RosettaSynonymBody.metaValues,
          defaultValue: []
        },
        patternMatch: {
          name: RosettaSynonymBody.patternMatch
        },
        patternReplace: {
          name: RosettaSynonymBody.patternReplace
        },
        removeHtml: {
          name: RosettaSynonymBody.removeHtml,
          defaultValue: false
        },
        values: {
          name: RosettaSynonymBody.values,
          defaultValue: []
        }
      },
      superTypes: []
    },
    RosettaSynonymSource: {
      name: RosettaSynonymSource.$type,
      properties: {
        externalClasses: {
          name: RosettaSynonymSource.externalClasses,
          defaultValue: []
        },
        externalEnums: {
          name: RosettaSynonymSource.externalEnums,
          defaultValue: []
        },
        name: {
          name: RosettaSynonymSource.name
        },
        superSources: {
          name: RosettaSynonymSource.superSources,
          defaultValue: [],
          referenceType: RosettaSynonymSource.$type
        }
      },
      superTypes: [RosettaRootElement.$type]
    },
    RosettaSynonymValueBase: {
      name: RosettaSynonymValueBase.$type,
      properties: {
        maps: {
          name: RosettaSynonymValueBase.maps
        },
        name: {
          name: RosettaSynonymValueBase.name
        },
        path: {
          name: RosettaSynonymValueBase.path
        },
        refType: {
          name: RosettaSynonymValueBase.refType
        },
        value: {
          name: RosettaSynonymValueBase.value
        }
      },
      superTypes: []
    },
    RosettaType: {
      name: RosettaType.$type,
      properties: {},
      superTypes: []
    },
    RosettaTypeAlias: {
      name: RosettaTypeAlias.$type,
      properties: {
        conditions: {
          name: RosettaTypeAlias.conditions,
          defaultValue: []
        },
        definition: {
          name: RosettaTypeAlias.definition
        },
        name: {
          name: RosettaTypeAlias.name
        },
        parameters: {
          name: RosettaTypeAlias.parameters,
          defaultValue: []
        },
        typeCall: {
          name: RosettaTypeAlias.typeCall
        }
      },
      superTypes: [RosettaRootElement.$type, RosettaType.$type]
    },
    RosettaTypedFeature: {
      name: RosettaTypedFeature.$type,
      properties: {},
      superTypes: []
    },
    RuleReferenceAnnotation: {
      name: RuleReferenceAnnotation.$type,
      properties: {
        empty: {
          name: RuleReferenceAnnotation.empty,
          defaultValue: false
        },
        name: {
          name: RuleReferenceAnnotation.name
        },
        path: {
          name: RuleReferenceAnnotation.path
        },
        reportingRule: {
          name: RuleReferenceAnnotation.reportingRule,
          referenceType: RosettaRule.$type
        }
      },
      superTypes: []
    },
    Segment: {
      name: Segment.$type,
      properties: {
        feature: {
          name: Segment.feature,
          referenceType: RosettaTypedFeature.$type
        },
        next: {
          name: Segment.next
        }
      },
      superTypes: []
    },
    ShortcutDeclaration: {
      name: ShortcutDeclaration.$type,
      properties: {
        definition: {
          name: ShortcutDeclaration.definition
        },
        expression: {
          name: ShortcutDeclaration.expression
        },
        name: {
          name: ShortcutDeclaration.name
        }
      },
      superTypes: [AssignPathRoot.$type, RosettaSymbol.$type]
    },
    SortOperation: {
      name: SortOperation.$type,
      properties: {
        argument: {
          name: SortOperation.argument
        },
        function: {
          name: SortOperation.function
        },
        operator: {
          name: SortOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    SumOperation: {
      name: SumOperation.$type,
      properties: {
        argument: {
          name: SumOperation.argument
        },
        operator: {
          name: SumOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    SwitchCaseGuard: {
      name: SwitchCaseGuard.$type,
      properties: {
        literalGuard: {
          name: SwitchCaseGuard.literalGuard
        },
        referenceGuard: {
          name: SwitchCaseGuard.referenceGuard,
          referenceType: SwitchCaseTarget.$type
        }
      },
      superTypes: []
    },
    SwitchCaseOrDefault: {
      name: SwitchCaseOrDefault.$type,
      properties: {
        expression: {
          name: SwitchCaseOrDefault.expression
        },
        guard: {
          name: SwitchCaseOrDefault.guard
        }
      },
      superTypes: []
    },
    SwitchCaseTarget: {
      name: SwitchCaseTarget.$type,
      properties: {},
      superTypes: []
    },
    SwitchOperation: {
      name: SwitchOperation.$type,
      properties: {
        argument: {
          name: SwitchOperation.argument
        },
        cases: {
          name: SwitchOperation.cases,
          defaultValue: []
        },
        operator: {
          name: SwitchOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ThenOperation: {
      name: ThenOperation.$type,
      properties: {
        argument: {
          name: ThenOperation.argument
        },
        function: {
          name: ThenOperation.function
        },
        operator: {
          name: ThenOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ToDateOperation: {
      name: ToDateOperation.$type,
      properties: {
        argument: {
          name: ToDateOperation.argument
        },
        operator: {
          name: ToDateOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ToDateTimeOperation: {
      name: ToDateTimeOperation.$type,
      properties: {
        argument: {
          name: ToDateTimeOperation.argument
        },
        operator: {
          name: ToDateTimeOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ToEnumOperation: {
      name: ToEnumOperation.$type,
      properties: {
        argument: {
          name: ToEnumOperation.argument
        },
        enumeration: {
          name: ToEnumOperation.enumeration,
          referenceType: RosettaEnumeration.$type
        },
        operator: {
          name: ToEnumOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ToIntOperation: {
      name: ToIntOperation.$type,
      properties: {
        argument: {
          name: ToIntOperation.argument
        },
        operator: {
          name: ToIntOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ToNumberOperation: {
      name: ToNumberOperation.$type,
      properties: {
        argument: {
          name: ToNumberOperation.argument
        },
        operator: {
          name: ToNumberOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ToStringOperation: {
      name: ToStringOperation.$type,
      properties: {
        argument: {
          name: ToStringOperation.argument
        },
        operator: {
          name: ToStringOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ToTimeOperation: {
      name: ToTimeOperation.$type,
      properties: {
        argument: {
          name: ToTimeOperation.argument
        },
        operator: {
          name: ToTimeOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    ToZonedDateTimeOperation: {
      name: ToZonedDateTimeOperation.$type,
      properties: {
        argument: {
          name: ToZonedDateTimeOperation.argument
        },
        operator: {
          name: ToZonedDateTimeOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    },
    TypeCall: {
      name: TypeCall.$type,
      properties: {
        arguments: {
          name: TypeCall.arguments,
          defaultValue: []
        },
        type: {
          name: TypeCall.type,
          referenceType: RosettaType.$type
        }
      },
      superTypes: []
    },
    TypeCallArgument: {
      name: TypeCallArgument.$type,
      properties: {
        parameter: {
          name: TypeCallArgument.parameter,
          referenceType: TypeParameter.$type
        },
        value: {
          name: TypeCallArgument.value
        }
      },
      superTypes: []
    },
    TypeParameter: {
      name: TypeParameter.$type,
      properties: {
        definition: {
          name: TypeParameter.definition
        },
        name: {
          name: TypeParameter.name
        },
        typeCall: {
          name: TypeParameter.typeCall
        }
      },
      superTypes: [RosettaSymbol.$type]
    },
    WithMetaEntry: {
      name: WithMetaEntry.$type,
      properties: {
        key: {
          name: WithMetaEntry.key,
          referenceType: RosettaFeature.$type
        },
        value: {
          name: WithMetaEntry.value
        }
      },
      superTypes: []
    },
    WithMetaOperation: {
      name: WithMetaOperation.$type,
      properties: {
        argument: {
          name: WithMetaOperation.argument
        },
        entries: {
          name: WithMetaOperation.entries,
          defaultValue: []
        },
        operator: {
          name: WithMetaOperation.operator
        }
      },
      superTypes: [RosettaExpression.$type]
    }
  } as const satisfies langium.AstMetaData;
}

export const reflection = new RuneDslAstReflection();
